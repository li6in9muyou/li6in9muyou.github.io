[ { "title": "rg 基础。rg 101", "url": "/posts/rg-101/", "categories": "HowTo", "tags": "rg, tooling", "date": "2024-06-26 00:00:00 +0800", "snippet": "THIS IS A WORK IN PROGRESSsearch PATTERN in files but exclude files whose path matches EXCLUDE_PATH_PATTERN! means exclude, -g option expects GLOB not regex.$ rg hello -g !*node_modules*", "content": "THIS IS A WORK IN PROGRESSsearch PATTERN in files but exclude files whose path matches EXCLUDE_PATH_PATTERN! means exclude, -g option expects GLOB not regex.$ rg hello -g !*node_modules*" }, { "title": "git 基础。git 101", "url": "/posts/git-101/", "categories": "HowTo", "tags": "git, tooling", "date": "2024-05-10 00:00:00 +0800", "snippet": "THIS IS A WORK IN PROGRESSfetch a huge code base partiallyreference&gt; git clone ssh://git@example.com/.git --depth 1 --branch releaseuse the following command to further fetch all history but lea...", "content": "THIS IS A WORK IN PROGRESSfetch a huge code base partiallyreference&gt; git clone ssh://git@example.com/.git --depth 1 --branch releaseuse the following command to further fetch all history but leave out all the files which is relatively fast&gt; git fetch --filter blob:noneuse the following command to do git pull because git pull fails in repos init’ed with commands above.&gt; git fetch --refetch&gt; git pulloverview of untracked files and changed files&gt; git status --branch --short## main...origin/main M 2024-05-10-git-101.md?? bboverview of staged changes&gt; git diff --stat --staged _posts/2024-05-10-git-101.md | 15 +++++++++++++++ _posts/bb | 1 + 2 files changed, 16 insertions(+)stage/unstage filesReplace reset with add to stage files.&gt; git reset ${path}Unstaged changes after reset:M _posts/2024-05-10-git-101.mdstage/unstage some lines in a fileDo this in an editor.view git history of some lines in a fileUse the -L option of log.&gt; git lg -- .\\2022-06-05-debug-101.md* 097a0bf - (li6in9muyou 1 year, 2 months ago) fix: htmlproofer disagree with unicode paths* 8074d12 - (li6in9muyou 1 year, 2 months ago) chore: linting* cf1678d - (li6in9muyou 1 year, 2 months ago) chore: update image links* 423a881 - (li6in9muyou 1 year, 2 months ago) chore: linting with prettier* 5d28c97 - (li6in9muyou 1 year, 2 months ago) fix: html-proofer errors* 900fa15 - (li6in9muyou 1 year, 7 months ago) add chinese title for all posts&gt; git lg -L'14,18:.\\2022-06-05-debug-101.md' -s* 097a0bf - (li6in9muyou 1 year, 2 months ago) fix: htmlproofer disagree with unicode paths* cf1678d - (li6in9muyou 1 year, 2 months ago) chore: update image links* 423a881 - (li6in9muyou 1 year, 2 months ago) chore: linting with prettier* 5d28c97 - (li6in9muyou 1 year, 2 months ago) fix: html-proofer errors* fec61e0 - (li6in9muyou 1 year, 7 months ago) linting: prettier* 5958d6d - (Li6q 1 year, 11 months ago) posts: migrate postsdiff and applyPipe anything from git diff into any path.Then use git apply --verbose ${patch_path} --directory ${prepend_directory} to apply that patch.Paths in patch files are relative to .git.Use --directory option to adjust paths.download git submodule dependencies call sync to copy .gitmodules to .git/config update .git/config/config if needed call update to download submodules&gt; nvim .gitmodules&gt; git submodules sync&gt; git submodule update --remote --recursive --initdownload one branch and limited commitsUse --branch and --depth for faster cloning when all you want is to submit a pull request or read the code.&gt; git clone --branch main --depth=3 https://github.com/li6in9muyou/li6in9muyou.github.io.gitIf another branch is needed&gt; git remote set-branches origin gh-pages&gt; git fetch origin gh-pages&gt; git checkout -b gh-pages FETCH_HEAD" }, { "title": "大略了解并发模型。seven concurrency models in seven weeks", "url": "/posts/concurrency-models/", "categories": "Reading", "tags": "", "date": "2023-08-03 00:00:00 +0800", "snippet": "THIS IS A WORK IN PROGRESS这本书确实没有讲到事件循环线程和锁使用锁元语来完成并发程序的同步和互斥需求，很容易出错，不讨论了。函数式编程用不可变的状态，其他的跟下面的CSP 几乎一模一样，不讨论了。Clojure都是语言特性，不讨论了Actoractor 是一种由运行时维护的实体，actor 之间可以发送消息，消息是一种不可变的数据类型，被抽象为元组，消息的递送是异步...", "content": "THIS IS A WORK IN PROGRESS这本书确实没有讲到事件循环线程和锁使用锁元语来完成并发程序的同步和互斥需求，很容易出错，不讨论了。函数式编程用不可变的状态，其他的跟下面的CSP 几乎一模一样，不讨论了。Clojure都是语言特性，不讨论了Actoractor 是一种由运行时维护的实体，actor 之间可以发送消息，消息是一种不可变的数据类型，被抽象为元组，消息的递送是异步的，有队列作缓存，发送消息不会阻塞，但是接收消息时如果没有消息，就会阻塞。actor 创建时，指定一个消息处理函数，如下面的cache。跟CSP 也是很像的，靠运行时阻塞住函数执行，状态不变，但其实储存在栈帧。def cache(pages, size) do receive do {:put, url, page} -&gt; new_pages = Dict.put(pages, url, page) new_size = size + byte_size(page) cache(new_pages, new_size) {:get, sender, ref, url} -&gt; send(sender, {:ok, ref, pages[url]}) cache(pages, size) {:size, sender, ref} -&gt; send(sender, {:ok, ref, size}) cache(pages, size) {:terminate} -&gt; ## Terminate request - don't recurse endendreceive 是阻塞的直到有别的actor 给他发消息，也可以设定一个超时处理函数。actor 可以创建别的actor。创建actor 时，可以监听特殊的一个退出事件，并把退出的actor 重新启动。这样的监听退出事件并重启别的actor 的actor 又称为supervisor。这样一来，同时使用supervisor 和actor 可以构建一个树，内部节点为supervisor 叶子节点为actor ，我们可以把业务逻辑分散在数量众多的actor 里面，即使运行时出现异常也能很快恢复。但是重启的时候怎么恢复到退出时的状态，因人而异，这里不讨论了。Communication sequential processes应用程序的运行时提供一个抽象元语叫做channel ，有放入和取出两种操作，如果之前没人执行放入，取出操作阻塞，如果之前没人执行取出操作，放入操作阻塞。channel 对象作为函数参数或者从函数中返回。跟经典元语信号量有点类似，但是比他更方便；这样一来，等待IO 、等待用户操作等概念就可以用一种同步的代码来表达。对比如下代码，前一段是使用了回调函数，后一段是使用了channel 的。fetchData(searchTerm, funciont (result) { updateUI(result)})const $httpRequest = fetchData(searchTerm)const result = 取出($httpRequest)updateUI(result)channel 的实现方法之一是把使用了channel 的函数改写为一个状态机，状态是按照channel 的放入和取出操作来划分，输入自然就是各个channel 的阻塞状态的变化，例如：stateDiagram-v2[*] --&gt; beforeBlockbeforeBlock --&gt; afterBlock: 网络请求结束afterBlock --&gt; [*]afterBlock: 取出$httpRequest 之前beforeBlock: 取出$httpRequest 之后函数内的代码则在离开或者进入状态的时候执行，状态机的输入是由channel 的现实的运行时提供的。这种改写可以在编译时，自动生成代码，也可以是在程序运行的时候由运行时调度。Data parallelism with GPUGPU 里面有很多能并行运行的处理器，借助OpenCL、OpenGL 等编程接口，我们可以用他们更快的完成某些计算，不讨论了。Lambda architectureBatch layer这一层处理永恒真实并且不可变的数据，这个东西有时候需要稍微修改数据。例如，存储用户的收货地址时需要同时记录时间戳，否则单记录地址的话很容易就变化了。有了永恒真实的不可变数据，并行计算变得容易一些了。在实现上，我们可以使用MapReduce 之类的方法来根据这些不可变数据计算出衍生数据。但是根据这些数据计算出的衍生数据，需要比较长的时间，计算出的数据肯定是滞后，所以必须引入Speed layer 来实时响应需求。例如，分批计算的数据是按周汇总计算的，我们可以轻易借助这些周汇总数据来计算任意时间段内的数据。It calculate derived data over some raw data in advance to provide a batch view e.g. select sum(sales) from daily_sales group by WEEK(date) runs an aggregation function on weekly data.Afterwards, the same aggregation function that runs on any time interval can be computed with some pre-computed data.For example, when aggregating on a period of 10 days, it can find a pre-computed weekly data then merge aggregation results from the rest 3 days thus saving computation.Note there are two downsides in such batch-and-cache operation.One is that data records it pre-computed with can not be mutated after creation otherwise all pre-computed results will be invalidated.Second is that sometimes such batch view computation can take a significant amount of time i.e. batch view always lags behind and out-of-date.Speed layer这个部分只要能应付较短时间内产生的数据就可以了，实现方法是灵活多变的，不讨论了。" }, { "title": "快点、再快点。the pursuit of speed", "url": "/posts/pursuit-of-speed/", "categories": "", "tags": "", "date": "2023-07-01 00:00:00 +0800", "snippet": "THIS IS A WORK IN PROGRESS少做工更优算法利用领域知识减少做工 last N digits of fibonacci sequence is cyclic, thus one can calculate last N digits of the Xth number in the sequence with manageable time and memory m...", "content": "THIS IS A WORK IN PROGRESS少做工更优算法利用领域知识减少做工 last N digits of fibonacci sequence is cyclic, thus one can calculate last N digits of the Xth number in the sequence with manageable time and memory mark simple inputs beforehand so that expensive checks and defensive logic can be skipped later or a faster ad-hoc algorithm can be used. see v8-json-stringify lazy loading and lazy evalution.成批操作减少每次操作的overhead concat strings before output to stdout merge meshes to render them in a single draw call HTTP 2 multiplexing提前做工缓存 memory hierarchy CDNchallenges cache invalidation cache consistence预取 prefetch attributes in HTML索引 B 树流水线 CPU更多机器并行计算、专用硬件、一个指令多个数据" }, { "title": "前端面试题目。crap", "url": "/posts/interview-questions/", "categories": "", "tags": "memo", "date": "2023-07-01 00:00:00 +0800", "snippet": "THIS IS A WORK IN PROGRESS你说一下深拷贝和浅拷贝深浅拷贝的概念在有运行时自动内存空间管理的编程语言中是常见的概念。The deep copy algorithmDeep copying is naturally recursive. In lodash, the recurse entry isat a baseClone function andit suppor...", "content": "THIS IS A WORK IN PROGRESS你说一下深拷贝和浅拷贝深浅拷贝的概念在有运行时自动内存空间管理的编程语言中是常见的概念。The deep copy algorithmDeep copying is naturally recursive. In lodash, the recurse entry isat a baseClone function andit supports various flavors: shallow or deep flatten inherited properties copy symbols or notAt every invocation: If !isObject(value), it can be trivially cloned by returning argumente.g. (value)=&gt;value lodash.js#L2632C7-L2634 Give up cloning by returning literal {} or a caller-supplied parentobject if the value is Function, Error,or WeakMap lodash.js#L2656-L2658 Create an object of the same type, types are determined by “toString tags” Boolean, Date, Map, Set, Number, Array, RegExp:simply new value.constructor lodash.js#L6185 but take extra care infollowing cases RegExp has a lastindex that has to be copied manually if this Array is returned from RegExp#exec, remember to copy some particularproperties lodash.js#L6153-L6156 Symbol: use Symbol#valueOf if present otherwise fallbackto {} lodash.js#L4563 DataView, ArrayBuffer, Buffer: use native methods, Buffer#slice for deep clone and Buffer#copy forshallowclone lodash.js#L4506-L4515 Arguments, and generic Object i.e. everything else: be careful withprototypes lodash.js#L6167 if subject is Array, Set or Map, their values are cloned or linkedaccordingly lodash.js#L2670-L2678 enumerate over object keys and descend into their values, when recursion returns, assign cloned value tocorresponding key.Implementation detailsassign value to a keyconsider the following scenarios If this key is inherited , which can be checked with hasOwnProperty, overwrite only if two values are different.Make sure to use SameValueZero comparison. If the value is undefined, set it only if !(key in object)enumerate keysBut before enumerating any key,read https://developer.mozilla.org/en-US/docs/Web/JavaScript/Enumerability_and_ownership_of_properties first then handlethe following scenarios: whether to enumerate inherited property numeric indices in array-like objects including Array, Arguments, Buffer and its friends.See lodash.js#L3093-L3096The algorithm for enumerating own properties use Object#keys for most cases and use newArray[index] = oldArray[index] for array-like objects. add enumerable symbols with Object.getOwnPropertySymbolsThe algorithm for enumerating owned and inherited properties Use for ... of loop for enumerating both own and inherited properties. add enumerable symbols of every prototype on prototype chainblazingly fast associative containerAn associative container is needed to eliminate infinite recursion caused by cyclic references in cloningobjects. lodash uses native Map whenever possible. However, for compatibility reasons, lodash developers wrotetheir own implementation in multiple ways. To achieve better performance, various implementations are developed.One implementation uses [] as base container. Insert operation simply pushes a key-value tuple to the array. Queryoperations comparing every key one after another. This implementation is suitable for small containers and containershave mostly non trivially comparable keys. String, number, symbol, boolean are considered trivially comparable.Another implementation uses {} as base container. This implementation is suitable for trivially comparable objects.One complex implementation uses multiple simpler implementations for storing different types of keys. Another compleximplementation uses the array based one before changing to object based one when it has more than 200 keys.read more如何写出一个惊艳面试官的深拷贝There is one clever implementation in comment section.function deepClone(obj) { //数组或普通对象存在循环引用情况，使用map存储对象避免无限递归函数 //函数局部变量，函数执行完毕之后就可以被GC,无需替换为WeakMap const map = new Map(); //递归这个函数 function clone(target) { if (map.has(target)) return map.get(target); // 获取 target 的具体类型，返回：Number String Object Array RegExp ... const type = Object.prototype.toString .call(target) .replace(/\\[object (\\w+)\\]/, \"$1\"); //使用策略模式，处理每种类型的克隆 //You gotta be kidding me, strategy pattern, seriously? //More like replacing switch case with lookup table. const strategy = { // Array和Object可以公用一个函数 ObjectOrArray() { // const result = Array.isArray(target) ?[]:{} const result = new target.constructor() // !在迭代开始前进行set map.set(target, result) for (const [k, v] of Object.entries(target)) { result[k] = clone(v); } return result; }, Map() { const newMap = new Map(); target, forEach((v, k) =&gt; { newMap.set(clone(k), clone(v)); }); return newMap; }, Set() { const newSet = new Set(); target.forEach((item) =&gt; { newSet.add(clone(item)); }); return; }, Date() { return new Date(target.valueOf()); }, RegExp() { const newReg = new RegExp(target.source, target.flags); newReg.lastindex = target.lastindex; return newReg; }, Error() { return new Error(target.message); }, // ...可添加支持更多对象类型 }; if ([\"Array\", \"Object\"].includes(type)) { return strategy.ObjectOrArray(); } else { return strategy[type] ? strategy[type]() : target; } } return clone(obj);}你说一下响应式设计响应式设计就是一批行业内的最佳实践，用来处理不同屏幕大小和屏幕方向对网页的影响，从而给用户最好的体验。主要着力点是三个方面：页面布局、图片、文字。详见https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Responsive_Design页面布局应该根据屏幕尺寸调整视觉元素的布局，例如，在窄屏幕上使用单列布局，在宽屏幕上采用多列布局；在窄屏幕上将列表合并为下拉菜单，在宽屏幕上则将其展开。图片响应式的做法主要是给同一个图片提供多种不同分辨率、不同尺寸、不同容量的图片源供用户代理选用，其目标是在不同的屏幕大小和不同的带宽环境下使用合适用户的图片。有时，仅仅在在小屏幕上使用小容量的图片在大屏幕上使用大容量图片以期节省用户的网络流量可能还不够，这篇文章讲述了有时应该在在小屏幕上提供局部特写照片，而在宽屏幕上可是适当提供远景照片，也就是说图片响应式也应该适配画面的内容。文字响应式的做法是根据屏幕大小尺寸调整文字的大小，例如在大屏幕上可以适当增大标题文字的尺寸。可以用 media query 和 viewport units 来实现。你说一下跨域用户代理中通常执行同源策略。在此基础上，用户代理又提供 CORS 作为一种宽松措施。主要过程通常情况下这个过程对 JavaScript 是透明的，除非你要读取服务器响应中特殊的 HTTP 头或者使用服务器发回的HTTP cookie 等身份信息。在发送 CORS 请求时，用户代理会发送OriginHTTP 头来指示当前 JavaScript 是属于哪个站点。有的 CORS 请求被认为是简单请求，如 GET 和某些 POST 请求。如果用户代理认为某请求不是简单请求，用户代理会在发送真正的 HTTP 请求之前用 HTTP OPTIONS 方法发送一个 preflight请求来查询服务器是否允许 CORS 请求中使用的 HTTP 头和 HTTP 方法。查询方法是填写如下字段 Access-Control-Request-Method：填写 HTTP 方法 Access-Control-Request-Headers：填写 HTTP 头服务器应答中要包括Access-Control-Allow-Origin，为了回答上面的查询还要对应地填写Access-Control-Allow-Methods和Access-Control-Allow-Headers。此外，为了其他的目的，还可包括其他的头，见https://fetch.spec.whatwg.org/#http-responses常用的有： Access-Control-Allow-Credentials：用来控制本次请求的credentials mode，模式有：不使用、同源则使用、要使用。Credentials指的是 HTTP cookie、TLS 客户端证书、authentication entries (for HTTP authentication)。 Access-Control-Expose-Headers：将列出来的 HTTP 头暴露给 JavaScript。下面是三个使用 CORS 的例子 featch(\"https://example.com\") JavaScript 要读取 HTTP 响应头 服务器需要 HTTP cookie 来识别用户目的、作用与局限其目的是为了放宽同源策略的限制，在同源策略中，用户代理只能向同一个源发送 HTTP 请求，如果使用 CORS 的话，可以在其他源服务器同意的情况下，访问其资源。跨域请求是有一定的安全风险的，假若这些请求中带上了用户代理中储存的用户的身份信息，如 HTTP cookie，那么其他源的 web 应用就可假冒这个用户进行操作。例如，假若用户代理没有实现同源策略，用户访问钓鱼网站时，该钓鱼网站就可以向真实站点发送带有用户身份信息的 HTTP 请求，给用户造成伤害。如果实现了同源策略，钓鱼网站将通过 CORS 与真实站点交互，这样用户代理会与真实站点进行握手，真实站点可以指示用户代理自己是否信任钓鱼网站所在的源，如不信任，用户代理就不会发送后继请求。当然，攻击者也可以用其他的 HTTP 客户端，带上用户身份信息来访问真实站点，这攻击方法属于 CSRF 攻击，防范方法见https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#double-submit-cookie你说一下怎么判断数据的类型ArrayArray.isArray sourceNaN用x != +x，注意Number.isNaN不做类型强制转换，而global的isNaN会做，这导致不能成功转成数字的值都会被认为是NaN。元语值元语值如下： null undefined true、falsesource用===，注意Object.prototype.toString.call返回相应的大写的[object xxx]。内置类型的字符串标记见此处Objectsource不为null且typeof得object或function数字、字符串用typeof，Number和String用通用方法。通用方法source用Object.prototype.toString.call，然后按照返回值判断，如果要判断的值自己覆盖了toString，要先把这个方法置undefined再调用，然后再恢复原方法。例如，判断是否Functionfunction isFunction(value) { if (!isObject(value)) { return false; } var tag = baseGetTag(value); return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;}你说一下let、const、varvar的声明会被提升，可见域是当前包围的函数和子函数。未完待续……你说一下箭头函数箭头函数不能用作构造函数，也没有自己的this和arguments绑定，并且不应该用作属性方法。未完待续……你说一下水平居中垂直居中水平居中文字用text-align，其他元素可以用display: inline-block。宽度确定的块元素用margin: auto垂直居中文字可把行高设置为父元素高度，如字体不对劲，可用vertical-align微调，其他元素可以用display: inline-block。都可以 absolute元素用对应方向上的两个属性置0 absolute元素用left: 50% top: 50%然后再用transform[XY](-50%)往回调整 display: flex然后设置恰当的属性。你说一下怎么隐藏一个元素 display: none：宽高为0，不占位置，点击不了。 visibility: hidden：宽高正常，占位置，点击不了。 opacity: 0：宽高正常，占位置，能点击。 宽高设置0：外边距占位置，内容会溢出。 z-index设置足够小：宽高正常，占位置，要有其他元素遮挡，否则能看到却不能点击。 把元素位置移到视口之外：呵呵。你说一下 HTTP 123HTTP 2 同一个 TCP 连接可以传输多个 web 对象，这些 web 对象在 stream 中传输，stream 都分配了权重和依赖用来决定服务器处理的先后顺序。HTTP 2 的头部是二进制的，并且可以在 web 对象之间复用。最后，HTTP 2 的服务器可以发回多个回复，如果客户端指定的话。对前端开发者来说，没有任何影响没有任何影响没有任何影响。严禁在本博客抖机灵，所有内容必须清楚表达意思。你说一下什么是事件循环浏览器中的事件循环（Event Loop）是一个无限循环，它负责不断地从一个任务队列中取出待执行的任务（如用户的点击、定时器或网络请求回调），并将其按顺序推送到调用栈上执行，从而确保所有任务都能在不阻塞主线程的情况下得到处理。他的主要目的是实现并发编程。你说一下排序算法选择排序（selection sort）：每次找出最小的那个元素，把他取出放到一个新数组，直到原数组为空，新数据就排序完成了。冒牌排序（bubble sort）：从左到右反复交换相邻的每个元素使得这两个数字是从小到大，一直重复到没有数字需要交换位置为止。快速排序（quick sort）：写成递归形式 递归分解就是选出数组里的某一个数，然后把比他小的数放到一个数组，比他大的数放到另一个数组，对这两个数组往下递归 递归合并就是把小数递归结果、自己、大数递归结果做数组连接 递归出口就是传入空数组此时返回空数组。你说一下js 里面有多少种创建对象的方式啊两个花括号。写一个构造函数和用class 语法，这两个的差别在于class 帮你调用了父类的构造函数并把prototype 连接好了，构造函数的话需要手动来写。还有其他几个创建方法，具体问ai 吧。你说一下前端开发用到的工具吧TODO" }, { "title": "好的工具。a curated list of tools", "url": "/posts/awesome-tools/", "categories": "", "tags": "memo", "date": "2023-06-30 00:00:00 +0800", "snippet": "lorem ipsum but it’s picturehttps://placehold.co/600x400/orange/bluecopy a directory and its git historyThis article outlines the cherry-picking approach. Create a new git repo, git init Set orig...", "content": "lorem ipsum but it’s picturehttps://placehold.co/600x400/orange/bluecopy a directory and its git historyThis article outlines the cherry-picking approach. Create a new git repo, git init Set original repo as a remote, git remote add hmwk file://path/to/original/repo Download history from original repo, git remote update List commits that change this directory, git log -- day2009-bouncing-discs. Or use helper in IDE. Cherry-pick commits from remote, git cherry-pick f1a6884d^..5dfa0336 if commits are consecutive. Or cherry-pick them one by one.However, cherry-pick will throw fatal error if specified hash range contains merge commit.And commits from another branch will be “merged” to HEAD which is a very undesirable behaviour.Subtree merging approach preserves merge commits and full commit history,see this link.Excerpt: Here is the command sequence you need: $ git remote add -f Bproject /path/to/B &lt;1&gt;$ git merge -s ours --no-commit --allow-unrelated-histories Bproject/master &lt;2&gt;$ git read-tree --prefix=dir-B/ -u Bproject/master &lt;3&gt;$ git commit -m \"Merge B project as our subdirectory\" &lt;4&gt;$ git pull -s subtree Bproject master &lt;5&gt; name the other project “Bproject”, and fetch. prepare for the later step to record the result as a merge. read “master” branch of Bproject to the subdirectory “dir-B”. record the merge result. maintain the result with subsequent merges using “subtree” The first four commands are used for the initial merge, while the last one is to merge updates from B project.git stashgit stash common commands includes: list, push, pop/apply, show. Their meaning are pretty strateforward and don’t forget to use git stash show -p to show stash detail. For options other than “-p” see “DIFF FORMATTING” section in git show --help." }, { "title": "面向教室又面向对象的程序设计语言编译器。COOL compiler", "url": "/posts/COOL-compiler/", "categories": "Learning", "tags": "compiler, bash", "date": "2023-03-20 00:00:00 +0800", "snippet": "THIS IS A WORK-IN-PROGRESSThis post will be a summary of programming assignments ofthis free course on edx.These programming assignments builds a compiler for the COOL programming. This language is...", "content": "THIS IS A WORK-IN-PROGRESSThis post will be a summary of programming assignments ofthis free course on edx.These programming assignments builds a compiler for the COOL programming. This language is a bit odd and quirky but it’squite more complex than the language of a previous work.Compared that project, this compiler for COOL seems more serious and covers more ground in the field of compiling.Do note that aforementioned interpreter project has a sequel that builds a compilers where a VM and byte code isdesigned and implemented. This COOL compiler will compile to MIPS assembly which is a well established architecture.I am quite surprised to see that prompted by my paragraph above, Bing Compose is able to generate the followingcontent. Besides being quite generic and lacking personality, it does not quite capture my experience working with theseprogramming assignments. I think its style is more akin to those marketing brochures. However, I do believe that givenfurther prompts, it is able to generate better content. Hi there! In this blog post, I’m going to share with you my experience of taking a free course on edx that teaches howto build a compiler for the COOL programming language. If you’re interested in learning more about compilers and howthey work, this course might be a good fit for you. What is COOL? COOL stands for Classroom Object-Oriented Language. It is a computer programming language designed by Alexander Aikenfor use in an undergraduate compiler course project . COOL resembles many modern programming languages, includingfeatures such as objects, static typing, automatic memory management, and simple reflection . COOL is not meant to beapractical language for real-world applications, but rather a pedagogical tool for learning about compiler design andimplementation. What does the course cover? The course is called “Compilers: Theory and Practice” and it’s offered by Stanford University on edx. The courseconsists of six modules that cover different aspects of compiler construction: Lexical analysis Parsing Semantic analysis Code generation Optimization Runtime systems Each module has video lectures, quizzes, readings, and a programming assignment. The programming assignments are themain focus of the course, as they require you to implement various components of a COOL compiler using C++ andFlex/Bison. The assignments are graded automatically using an online submission system. What did I learn? I learned a lot from this course about how compilers work and how to write one from scratch. Some of the topics that Ifound particularly interesting and challenging were: How to use regular expressions and finite automata to recognize tokens in a source program How to use context-free grammars and parsing algorithms to build abstract syntax trees How to use symbol tables and type checking rules to perform semantic analysis How to use code generation techniques such as register allocation and instruction selection to produce MIPS assembly code How to use optimization techniques such as dead code elimination and constant folding to improve the performance of the generated code How to use runtime systems such as stack frames and garbage collection to manage memory allocation I also learned how to use some tools that are commonly used in compiler development, such as: Flex: A tool for generating scanners (lexical analyzers) from regular expressions Bison: A tool for generating parsers (syntax analyzers) from context-free grammars Spim: A MIPS simulator that can execute assembly code generated by the COOL compiler How did I find the course? I found the course very engaging and rewarding. The lectures were clear and concise, the quizzes were helpful forchecking my understanding, the readings were informative and relevant, and the assignments were challenging but fun.Theinstructors were very knowledgeable and responsive, answering questions on the discussion forums or via email. Theonline submission system was easy to use and provided instant feedback on my solutions. The only downside of the course was that it was quite demanding in terms of time commitment. Each assignment took meseveral hours or even days to complete, depending on its complexity. I had to balance my time between watchinglectures, doing quizzes, reading materials, coding solutions, testing them, and debugging them.It was not an easy task, especially since I had other commitments outside of this course.However, I think it was worth it, as I gained valuable skills and knowledge that will help me in my future endeavors. Who should take this course? This course is suitable for anyone who has some background in programming (preferably C++) and wants to learn moreabout compilers. It is not necessary to have prior experience with compilers or assembly language,but it would be helpful if you have some familiarity with basic concepts such as data structures,algorithms, and discrete mathematics.The course is also suitable for anyone who enjoys solving problems, learning new things, and creating something cool(pun intended) programs. Conclusion In conclusion,this course was one of the best online courses I’ve ever taken.It taught me how to build a compiler for a fairly complex programming language using modern tools and techniques.It also challenged me intellectually and creatively,making me think deeply about various aspects of compiler design and implementation.I highly recommend this course to anyone who wants to learn more about compilers or just have some fun withprogramming. If you’re interested in taking this course,you can find it here:https://www.edx.org/course/compilers-theory-and-practice Thanks for reading!" }, { "title": "伯恩命令解释器常识。Bash 101", "url": "/posts/bash-101/", "categories": "Learning", "tags": "linux, bash", "date": "2023-03-19 00:00:00 +0800", "snippet": "if statementsWrap boolean expressions with [ ].Use (( )) and == to compare numbers.Use = to compare strings.There must be a space after [ of (( and before ] or )).if echo \"$str\" | grep -q \"^whate...", "content": "if statementsWrap boolean expressions with [ ].Use (( )) and == to compare numbers.Use = to compare strings.There must be a space after [ of (( and before ] or )).if echo \"$str\" | grep -q \"^whatever\";; then # whateverfiif (( a == 1 || b == 2 )); then # whateverfiif [ \"d\" = \"d\" ]; then # whateverfiif [ -d \"path/to/some-dir\" ] &amp;&amp; [ -f \"some-file\" ] then # whateverficommand expansionsSimple expansion Tilde expansion: echo ~ yields /home/dev Parameter expansion: echo $winIp yields 172.18.112.1Arithmetic expansionBash shell does not natively support floating-point arithmetic. However, you can use the bc command to performfloating-point arithmetic in Bash. bc is an arbitrary precision calculator language that can handle floating-pointnumbers.$ echo $(( 2 + 2 ))4$ echo $(( 2 * 3 ))6$ echo $(( 10 / 2 ))5$ echo $(( 10 % 3 ))1$ echo $(( 2 ** 3 ))8$ echo \"scale=4; 22/7\" | bc3.1428$ echo \"scale=7; 333/106\" | bc3.1415094In the above example, we used the $(( )) syntax to perform integer arithmetic expansion. The scale variable is used tospecify the number of decimal places to display in the result. In this case, we set it to 2 to display two decimalplaces. The | symbol (vertical line i.e. pipe symbol) is used to pipe the output of the echo command to bc.Pathname expansionPathname expansion is used to generate a list of filenames that match a pattern. Here are some examples of pathnameexpansion: echo * yields all files in the current directory echo *.txt yields all files in the current directory that end with .txt echo /usr/*/share yields all directories in /usr that have a subdirectory called share echo ./test/input-*.txt yields all input-1.txt, input-2.txt, input-999.txt. echo \"*.dat* yields all file and directory names that contain .dat.Grouped brace expansion is also supported.For example, if you have a large collection of images you want to organizeinto years and months, you can create a series of directories named in numeric “Year-Month” format. This way, thedirectory names will sort in chronological order. Instead of typing out a complete list of directories, you can usepathname expansion to create them quickly and easily. Here’s an example:Brace expansion echo chapter{1..3} yields chapter1 chapter2 chapter3. echo {A..Z..2} yields A C E G I K M O Q S U W Y. echo {a..c}\" \"{1..3} yields a 1 a 2 a 3 b 1 b 2 b 3 c 1 c 2 c 3. Note that blank space is quoted. echo {a..c}{x,y}{1..3} yields ax1 ax2 ax3 ay1 ay2 ay3 bx1 bx2 bx3 by1 by2 by3 cx1 cx2 cx3 cy1 cy2 cy3.Pathname expansion is commonly used to create lists of files or directories to be created. For example, if you have alarge collection of images you want to organize into years and months, you can create a series of directories named innumeric “Year-Month” format. This way, the directory names will sort in chronological order. Instead of typing out acomplete list of directories, you can use pathname expansion to create them quickly and easily. Here’s an example:$ mkdir Photos$ cd Photos$ mkdir {2017..2019}-{01..12}$ echo {2017..2019}-{01..12}2017-01 2017-02 2017-03 2017-04 2017-05 2017-06 2017-07 2017-08 2017-09 2017-10 2017-11 2017-122018-01 2018-02 2018-03 2018-04 2018-05 2018-06 2018-07 2018-08 2018-09 2018-10 2018-11 2018-122019-01 2019-02 2019-03 2019-04 2019-05 2019-06 2019-07 2019-08 2019-09 2019-10 2019-11 2019-12This will create directories named 2017-01, 2017-02, 2017-03, and so on, up to 2019-12.Command substitutionCommand substitution allows you to use the output of a command as an argument to another command.For example, echo $(date) will print the current date and time.$ echo \"The current date is `date +%Y-%m-%d`\"The current date is 2023-03-19" }, { "title": "大略了解分布式系统。MIT6.824 Distributed Systems", "url": "/posts/distributed-systems/", "categories": "Reading", "tags": "distributed-system", "date": "2023-03-05 00:00:00 +0800", "snippet": "THIS IS A WORK-IN-PROGRESSThis free online course explains inner-workings of various distributed systems.FrangipaniFrangipani implements a shard storage among computers. There is Frangipani softwar...", "content": "THIS IS A WORK-IN-PROGRESSThis free online course explains inner-workings of various distributed systems.FrangipaniFrangipani implements a shard storage among computers. There is Frangipani softwarerunning on every user’s computer that emulates a file system where a lot of caching anddistributed system magic take place. This system also operates a centralizedserver called Petal that can simply be viewed as a reliable disk drive in this article’s context.Key challenges of such system are:cache coherencetricky scenarios: After one computer creates a new file on the system, other computers are expected tosee this change as soon as possible. When multiple computers are modifying a same file or directory, those modification should notinterference each other unexpectedly.To address above issues, IO operations on shard files follows strict rules. cache is invalid without holding a lock acquire a lock before read write before release a lockoperation abstractions between a Frangipani client and Petal: request to a lock server grant a lock to a client revoke a lock from a client release a lock back to lock serverLock has BUSY and IDLE state.Lock is cached in client in a IDLE state as long as it has not been revoked.One type of lock is shard read lock, another type is of course an exclusive write lock.Anyone who reads a file must acquire a read lock first. Subsequently, he lock server revokesany write lock. But no Frangipaniclient busy writing shall be interrupted, lock server and all reader must wait for its writingoperation. Luckily, there is a big chance that such write lock is in IDLE state.This process make sure that no one will be reading stale data since write must give writingbefore any reader can read.atomicityThe system should grantee some file operations be atomic e.g. create and delete files.crash recoverytricky scenarios: Even if a computer crashes in the middle of syncing local state to the central server,other computer should not be affected by it.Write-Ahead-Log is used for crash recovery. Timeouts are also used to eliminate waiting indefinitelyfor responses from a Frangipani client. WALs are meant to be replayed by other peers.The lecturer distinguishes file metadata between user content. But how does the Linux OS implementfile system?Sequenced numbers are used to track WAL entries and filesystem changes so that future readersof same file entry are able to find the latest one. In such scenario, sequence number is oftencalled version number, which is very common in document-oriented NoSQL databases.The lecturer comments that the Frangipani system is not suitable for today’s use case of shardfile storage. A review of this software can be foundat wenzhe.one/MIT6.824%2021Spring/frangipani.htmlDistributed Transactions (Distr. Xactions.)Distributed transactions are used when some bussiness logic requiresmodifying data across multiple servers.Two main topics of this lecture are concurrency control and atomic commit.A transaction packs series of operation into an atomic operation.To facilitate such operations,concurrent system often provides abstract primitives for application programmersthat mark the start and the end of a transaction. Another very useful abstraction would beto abort. When an abort happens, the execution system rolls back intermediate modifications.An abort may not indicates an error because interrupting a transaction can resolve a dead lock.The classical ACID: Atomic: all or none Consistent: ignored by this lecture Isolated: serializable Durable: changes are persistent on non-volatile storageWhat is serializable?Serializable execution means that a concurrent system is able to execute concurrenttransactions that yields the same result as if those concurrent transactions are executedin a serial fashion, in other words, one after another.How to implement a serializable system?concurrency controlThe two main strategies for concurrency control are pessimistic and optimistic concurrency control.Pessimistic concurrency control is a strategy that tries to prevent conflicts from happeningby locking data items, while optimistic concurrency control is a strategy that allowstransactions to proceed without locking data items and checks for conflictswhen the transaction is ready to commit.For example, let’s say that two computers, Computer A and Computer B, are trying to write to the same fileat the same time.With pessimistic concurrency control, Computer A would lock the file so thatComputer B can’t write to it until Computer A is done. Once Computer A is done,it would release the lock and Computer B would be able to write to the file.This way, there’s no chance of Computer A and Computer B writing to the file at the same timeand causing conflicts.With optimistic concurrency control, Computer A and Computer B would both be able towrite to the file at the same time. However, when they’re done, the system would checkto make sure that there are no conflicts between the changes that they made.If there are conflicts, the system would roll back the changes and ask Computer Aand Computer B to try again.two-phrase lockingIn the growing phase, a transaction acquires locks on data items as it reads and writes them. Once a lock is acquired,it cannot be released until the transaction is ready to commit i.e. all changes have been made.This ensures that other transactions cannot read or write the same data itemwhile the transaction is still in progress hence no one is able to see intermediate results.In the shrinking phase, a transaction releases all of its locks once it is ready to commit. This allows othertransactions to read and write the same data items.In distributed systems, data involved in a transaction may reside in different servers.What if one of them fails in the middle of a transaction, how are we going to do about that?two-phrase commitThis operation involves two phases: a prepare phase and a commit phase.In the prepare phase, the transaction coordinator sends a prepare message to all the servers involved in thetransaction. Each server then checks to see if it can commit the transaction. If a server cannot commit the transaction,it sends a abort message to the transaction coordinator. If all the servers can commit the transaction, they send aready message to the transaction coordinator.In the commit phase, the transaction coordinator sends a commit message to all the servers that sent a ready message.The servers then commit the transaction and send an acknowledgement message to the transaction coordinator. If a servercannot commit the transaction, it sends an abort message to the transaction coordinator.The transaction ID and a list operations on involved resources are exchanged between the transaction coordinator andparticipants. In addition to the transaction coordinator, there are two other roles in a two-phase commit: participantsand resource managers. Participants: servers that are involved in the transaction. Resource managers: software components that manage access to resources, such as databases or files, on behalf ofthe participants. Resource managers are required to manage access to resources, such as databases or files, on behalfof the participants. They ensure that the resources are accessed in a consistent and reliable manner.The interaction between the transaction coordinator and the client that initiates the transaction is as follows: The client sends a request to the transaction coordinator to begin a transaction. The transaction coordinator assigns a unique transaction ID to the transaction and sends a prepare message to all theparticipants involved in the transaction. Each participant checks to see if it can commit the transaction. If a participant cannot commit the transaction, itsends an abort message to the transaction coordinator. If all the participants can commit the transaction, they senda ready message to the transaction coordinator. The transaction coordinator sends a commit message to all the participants that sent a ready message. The participants then commit the transaction and send an acknowledgement message to the transaction coordinator. If aparticipantcannot commit the transaction, it sends an abort message to the transaction coordinator. The transaction coordinator sends a response to the client indicating whether the transaction was committed oraborted.In this two-phase commit protocol, the participants acquire locks during the prepare phase and release them during thecommit phase. The locks are acquired to ensure that the resources involved in the transaction are accessed in aconsistent and reliable manner.failure scenariosIf a participant server fails during the two-phase commit, the transaction coordinator will not receive a ready messagefrom that participant. The transaction coordinator will then send an abort message to all the participants that sent aprepare message. The abort message tells the participants to abort the transaction.For example, suppose a transaction involves three participants: A, B, and C. The transaction coordinator sends a preparemessage to all three participants. Participant A sends a ready message to the transaction coordinator, but participantsB and C do not. The transaction coordinator then sends an abort message to participants A, B, and C, telling them toabort the transaction.If a participant server fails after sending a ready message, the transaction coordinator will send a commit message toall the participants that sent a ready message. The participants will then commit the transaction and send anacknowledgement message to the transaction coordinator. If a participant server fails after receiving a commit message,the transaction coordinator will not receive an acknowledgement message from that participant. The transactioncoordinator will then send an abort message to all the participants that sent a commit message. The abort message tellsthe participants to abort the transaction.If the transaction coordinator server fails during the two-phase commit, the participants will not receive a commit orabort message from the transaction coordinator. The participants will then wait for a timeout period to elapse beforeaborting the transaction.For example, suppose a transaction involves three participants: A, B, and C. The transaction coordinator sends a preparemessage to all three participants and then fails before sending a commit or abort message. Participants A, B, and C willwait for a timeout period to elapse before aborting the transaction.A lot of things can go wrong in these operations, system designers have to prepare their system for various failures.In short, there is a lot of acknowledgements and back-and-forth between participants and coordinators, when any reply isnot received, the whole operations aborts. Participants use Write-Ahead-Log to grantee the transaction will be madebefore reply to coordinator.In short, write a log to persistent storage before doing anything publicly.In short, use timeout when holding a lock except you have promise to commit the operation.Drawback of two-phrase commit: Many RTT are required. Bottleneck at disk writes. Long lock holding time.To achieve high availability with this protocol, one must replicate different parties involved.atomic commit coming soonSpannerA system for perform transactions on distributed data that is shared across servers around the globe.Over ninety percent of the transactions on them is read-only.The basic setup: one spanner manages one copy of many data items. use paxos protocol to manage each data item" }, { "title": "Pacman如何做出有个性的反派。How does Pacman create ghosts with distinctive personalities", "url": "/posts/pacman-ghost-patterns/", "categories": "Reading", "tags": "game-dev, ai, pacman", "date": "2023-02-08 00:00:00 +0800", "snippet": "本文大致摘要了由 Chad Birch 撰写的这篇文章在这里游玩经典的 Pacman 游戏游戏中有四种颜色的反派它们都具有非常突出的个性，读者可在上面的链接中体验。八十年代的开发者们是如何给它们赋予个性的呢？该游戏在一固定的迷宫地图中进行，只考虑角色的移动时，地图可用正方形网格建模。各个角色只能沿着迷宫的路做上下左右四个方向的移动。反派们是如和决定自己的行动轨迹的呢？每到当达路口时，各角色都...", "content": "本文大致摘要了由 Chad Birch 撰写的这篇文章在这里游玩经典的 Pacman 游戏游戏中有四种颜色的反派它们都具有非常突出的个性，读者可在上面的链接中体验。八十年代的开发者们是如何给它们赋予个性的呢？该游戏在一固定的迷宫地图中进行，只考虑角色的移动时，地图可用正方形网格建模。各个角色只能沿着迷宫的路做上下左右四个方向的移动。反派们是如和决定自己的行动轨迹的呢？每到当达路口时，各角色都会有一个目标点，选择距离目标点最近的那个方向，但不能在路口回头。距离用当前位置和目标位置的直线距离，如果有两个方向打成平手，按照规定好的顺序来选择。反派们如何决定自己的目标点呢？这是反派们个性形成的关键。红色反派目标点始终是玩家的当前位置，这使得它总是穷追不舍。粉色反派目标点始终是沿着玩家前进方向上的第四格，这使得它有一点的前瞻性。蓝色反派该目标点计算较为复杂，先记玩家前进方向上的第二格为 center 点，再记现在红色反派的位置为 bottom-left 点，以 center 点为中心点，bottom-left 点为左下角点，按照游戏地图的网格，我们可以做出一个长方形，这一长方形的右上角即为目标点。这中目标点使得它的行动轨迹难以预测。橙色反派如果当前位置与玩家位置的直线距离小于 8 个单位，该目标点固定为地图左下角处的某一点。否则，其目标点为玩家当前位置，这使得它似乎没有要追逐玩家的意图。游戏 AI 的其他设计根据游戏进度和游戏故事设定，各反派 AI 的行为在三种模式间切换，在各模式下，它们的行为可概括为：游荡各反派的目标点分别是地图四角处的某点，结合上述的寻路决策算法，游荡模式下它们最终将各自转圈。追逐如上述。惊慌进入该模式时立即回头走，然后在各路口随机选择方向。" }, { "title": "炸飞机场游戏开发反思。Review of bomb airfield game", "url": "/posts/review-of-bomb-airfield-game/", "categories": "ProjectExperience", "tags": "teamwork, c#", "date": "2022-11-25 00:00:00 +0800", "snippet": "这是一篇草稿！本次开发过程最大的特点是各成员的参与度均较高，且充分使用了 git 协助开发。就系统设计和实现而言，我们通过网页接受用户输入并显示游戏状态，网页与 C# 二进制之间通过 WebSocket 交互。本系统是基于 TCP 协议实现点对点联机的双人对战游戏，主要由游戏主循环构成。为了简单起见，这一游戏循环是顺序执行并使用阻塞式 IO。即等待用户的输入、渲染游戏状态、收发 TCP 数据...", "content": "这是一篇草稿！本次开发过程最大的特点是各成员的参与度均较高，且充分使用了 git 协助开发。就系统设计和实现而言，我们通过网页接受用户输入并显示游戏状态，网页与 C# 二进制之间通过 WebSocket 交互。本系统是基于 TCP 协议实现点对点联机的双人对战游戏，主要由游戏主循环构成。为了简单起见，这一游戏循环是顺序执行并使用阻塞式 IO。即等待用户的输入、渲染游戏状态、收发 TCP 数据包时整个程序阻塞。我们设计的游戏主循环又不同于通常意义上的游戏循环，在交互式电脑游戏程序中，这样的游戏循环常需要每秒钟执行 60 次，每次循环都要刷新屏幕。手写纯 JavaScript 通过 WebSocket 和原生二进制沟通是非常困难的，应该基于现有的 RPC 协议栈来实现。一个突出的问题是推拉转换。推拉转换会带来JavaScript 环境下，有很多代码的执行是基于回调的“推”模式，例如大量使用的事件监听器模式，是由程序员提供事件处理函数，由框架、库、运行时中的代码来调用这一事件处理函数，将数据以函数调用时传入参数的形式，“推”给程序员编写的代码。而我们设计的游戏循环，是按照“拉”模式来设计的，即游戏循环中通过调用 UI 模块的方法来获取用户最近的输入。这种编程范式在处理操作系统原生窗口相关事件的程序中是比较常见的，例如在 SDL 中，程序员如下所示的这样拉取窗口接收到的事件。while (game_is_still_running) { SDL_Event event; while (SDL_PollEvent(&amp;event)) { // poll until all events are handled! // decide what to do with this event. } // update game state, draw the current frame}这里的问题在于，游戏循环阻塞在人工智能辅助计算使用的是完全搜索算法，用简单的文本存储了所有的棋盘数据。我用 C# 实现的基于 DFS 的棋盘状态穷举程序速度很慢，原因尚不明确，怀疑是内存分配太多太频繁。后来用 C++ 实现并输出为文本。示例如下，一共有六万八千多个这样的飞机场上飞机的摆法的记录。 @ @********** * * *** *** * * * @*** * * *算法简单介绍如下：一开始时对方机场上一百个方格的状态都是未知的，当人工智能模块接收到对方机场上方格的更新时，便根据这一个方格的状态筛选出余下的可能的所有棋盘。例如若已知某个方格上命中了对方的飞机，则可以排除那些此处没有飞机或者是飞机驾驶舱的机场。这之后再对一百个方格进行静态估值，选出下一回合要轰炸的位置。最简单的静态估值可以是对每一个方格，统计余下的所有可能的机场状态中这个方格上放有飞机的机场数量，数量多者得分高。团队统一的整个代码仓库的代码风格自动整理是非常必要的。代码风格整理可以帮助发现语法错误，例如，在这个提交中解决的问题，如果有自动代码风格整理，一开始就不会出错。这是把 JavaScript 的逗号当成分号来使用了，经过 prettier 的自动整理问题变得很明显，prettier 做的整理如这个提交所示。" }, { "title": "光线追踪器在一个周末。Ray tracer in a weekend", "url": "/posts/ray-tracer-in-a-weekend/", "categories": "ProjectExperience", "tags": "go, computer-graphics, ray-tracing", "date": "2022-11-15 00:00:00 +0800", "snippet": "I followedthis famous introductory book on ray tracing in the Go programming language. Key takeaways are: naive parallel execution is not the silver bullet for slow programs debugging this progra...", "content": "I followedthis famous introductory book on ray tracing in the Go programming language. Key takeaways are: naive parallel execution is not the silver bullet for slow programs debugging this program is hardDebugging math stuff is hard (if you don’t know the math)Debugger offer little help here because raw values of a Vec3 make no sense.All one can do is make sure basic operations on vectors are all correct. Then check key assumptionson which the whole system bases. The author of this book explicitly shows the bounds and orientationsof “film” space and world space. However, due to the use of PPM image encoding format, coordinate system ofthe viewport space is implicit. Meaning that it’s now clear to see the mapping between film space(classic math coordinate system) and screen space (top-left origin, y goes down, x goes right).bounds of vector spacesSome coordinate spaces use normalized coordinates. Some code assumes parameters passed in are normalizedinto some bounds. In contrast to the usage of normalized coordinates, some vectors must retain size informationhence they must not be normalized e.g. vectors describing the size of “film” of focal length.Furthermore, computer graphics community use floating point in [0, 1] to represent RGBA color,while some image processing lib use uint in [0, 255] and some lib requires 32bit integer for storingintermediate results of RGBA colors to prevent overflow when multiplying.coordinate system origins and handednessIn math world, coordinates starts at left-bottom corner while computer world coordinates usuallystarts at left-top corner. In view (a.k.a. camera) space, coordinate starts at the center of viewport.Handedness only exists in three dimension coordinate systems, screen space or image space withtop-left origins do not have a Z axis.In math world, x coordinates increases to the right, y coordinates increases upwards. These two axescan be trivially drawn on a two dimension plane be it a paper or a digital screen.After x and y axes are drawn as usual, handedness can be shown by how Z axis is shown.In left-handed coordinate system, the Z axis points into the screen. While in right-handed coordinate systemthe Z axis points out.Parallel execution is not the silver bulletOn a N core machine, computation-bound program like a ray tracer could not achieve a speed-up more thanN times. Speed-up at this magnitude falls short compared to algorithmic improvements.Utilizing goroutines, one may naively create a goroutine for every scanline in the image hoping toharness all the computation power.At first, I did just that, but it turns out takes even more time to render.wg := sync.WaitGroup{}for y := 0; y &lt; PictureBounds.Max.Y; y++ { go func(y int) { wg.Add(1) // render one row of pixels wg.Done() }(y)}wg.Wait()I know such slow-down is caused by race conditions. And I suspect that the random number generatoris the subject of contention. So I create a new random source for every goroutine, which ends upto be a satisfactory speed-up of roughly 4.5 times. But that’s all physical CPU cores can do for me, startingfrom here, only algorithmic acceleration techniques can reduce running time." }, { "title": "快速方便的文件传输工具。quick and straight-forward file transfer tool", "url": "/posts/quick-file-transfer/", "categories": "ProjectExperience", "tags": "magic-wormhole, web-wormhole", "date": "2022-11-11 00:00:00 +0800", "snippet": "THIS POST IS WORK-IN-PROGRESS本产品要解决的问题设备之间传输文件太麻烦，很多方法依赖与互联网服务，这些服务大都需要一个验证身份的步骤，例如，输入账号和密码、用手机 app 扫面二维码等。微信 QQ 手机版接收到的文件要经过繁琐操作才能用其他应用打开。微信 QQ 电脑版接收到的文件不知道放在哪个文件夹都是埋得很深，还需要手动移出放入合适的文件夹。特点 省事...", "content": "THIS POST IS WORK-IN-PROGRESS本产品要解决的问题设备之间传输文件太麻烦，很多方法依赖与互联网服务，这些服务大都需要一个验证身份的步骤，例如，输入账号和密码、用手机 app 扫面二维码等。微信 QQ 手机版接收到的文件要经过繁琐操作才能用其他应用打开。微信 QQ 电脑版接收到的文件不知道放在哪个文件夹都是埋得很深，还需要手动移出放入合适的文件夹。特点 省事，用户只要用浏览器访问系统的地址，输入简单好记的顺口溜就可以开始使用，不要登陆，不要注册。 全平台，有浏览器并且可以下载文件的平台就可以使用。 跟竞品的比较一个人手机电脑互传 微信、QQ 等工具：需要在接收方也打开客户端才能接收，接收到的文件夹有时并不好找到也不方便指定。 各类云盘工具：需要登陆和注册，不充钱有下载速度限制。 数据线：在电脑查看手机上的文件目录可能很慢。多人互传 云盘链接很长很复杂，传输不方便。如果收方手机收到而想在电脑接收，那么这个人要把这条链接在设备之间互传，未必方便美团客服美团客服用短信给客户手机发送一条短信，短信中包含有一条链接。链接打开后可以填写文字和上传图片，提交后美团电话客服马上可以收到。最适合的应用场景 线下已经有互动，要在电子设备之间传输文件不适合的场景 网盘模式，分享者长期地分享自己的文件，收方接收时间不确定 离线发送模式，收方发方其中一方不在线未来的工作从现有的解决方案出发，还有如下工作要做： 改口令为中文、汉语中的成语熟语常用语 改交互界面的输入为简单点击 国内的很短的一个域名，作为 web 界面的入口 这个工具可以同时有多个接收方吗这一工具为了复用 magic wormhole 协议的代码，将 Go 实现的协议栈编译为 WASM 后，部署到浏览器中运行。现有的解决方案webwormhole.io基于 magic wormhole 协议，用户输入一个三个单词的口令就可以跟他人连接。该产品静态资源和 STUN 服务器都访问比较慢，而且不能中断后继续连接。移动用户切换 WIFI 接入点或切换移动互联网后连接就中断，已经传输的部分作废。sendfiles.dev使用简单 WebRTC，用户输入一长串 UUID 后可以跟他人连接，交换这一 UUDI 很不方便。" }, { "title": "重构书单分享应用。refactoring book list sharing app", "url": "/posts/refactor-book-list-app/", "categories": "ProjectExperience", "tags": "frontend, refactor", "date": "2022-11-05 00:00:00 +0800", "snippet": "This web app is initially built with svelte without much third party dependencies.Its features include: fetching book list from api apply filtering by regex select/unselect multiple items in lis...", "content": "This web app is initially built with svelte without much third party dependencies.Its features include: fetching book list from api apply filtering by regex select/unselect multiple items in list add/remove books to a book list create book list extensive use of loading spinners user login/logout/register client-side routingSystem overview before refactoringLibrary.svelte componentThis component has many child components. It passes many functions down to its childrenvia setContext mechanism provided by Svelte. These functions are used to config thefiltering and to control multi-selection state. For example,in the original postI have cataloged the followingA Filter object is shared between Library.svelte componentand a Filter.svelte component. The root component listens for changes to this Filterobject and update item listing, Filter.svelte updates this object upon user interactions.Multi-selection helpers i.e. select-all/reverse-selection/clear-selection are implemented ina similar fashion.Furthermore, this Library.svelte component toggles the AddToBookListModal.svelte componentwhen user choose to add all books in current selection to her book list.However, this AddToBookListModal.svelte should be shown when user choose toadd one single book to her book list.These two use cases are essential to this simple app, but it’s not clear to see that theyare properly implemented because the hierarchy of components obscures the control follow.Programmer must trace from AddToBookListModal.svelte back to its various clients then tosome click event handlers, only then she could conclude that these two use cases areimplemented. The diagram below illustrates this process.flowchartAddToBookListModal.svelte--&gt; |search for import statement|L[Library.svelte]--&gt; |\"bind:shouldShow={showBatchAdd}\"|B1[\"on:click={() =&gt; (showBatchAdd = true)}\"]--&gt; M1[make sure that this button is the right one]AddToBookListModal.svelte--&gt; |search for import statement|AP[ActionPanel.svelte]--&gt; |\"follow bind:shouldShow={shouldShowAddToBookListModal}\"|B2[\"bind:checked={shouldShowAddToBookListModal}\"]--&gt; M2[make sure that this checkbox is the right one]Besides the mental overhead described above, in that example ActionPanel.svelte is actuallyalso a child of Library.svelte, which means that when Library.svelte is renderedthere is actually two instances of AddToBookListModal.svelte in the subtree ofLibrary.svelte.This will an an issue if the duplicated components possess some resources e.g. access tokens.Refactoring proposalUse redux through redux-toolkit.Pocketbase frontend designpocketbase/ui/src/storesApp wide states, e.g. active collection, are stored hereas well as states of toasts, confirmations and error notifications.pocketbase/ui/src/actionsThere is only one file implementing a simple tooltip." }, { "title": "用swing开发数据库CRUD应用。Build a CRUD app with JDBC and swing", "url": "/posts/jdbc-crud-swing-app/", "categories": "ProjectExperience", "tags": "java, database, jdbc, gui, swing", "date": "2022-11-04 00:00:00 +0800", "snippet": "仓库地址：github.com/li6in9muyou/SwingDbCrudApp本项目中，使用 Java 的 Swing 组件开发了一个简单的 GUI 应用程序。简单在于其数据流是单向的。数据库中各表的数据填充在一JTable组件中，用户可直接修改各单元格的数据，其改动会被记录到暂存区，要想撤销暂存区中的改动是不能够的。flowchart LRa[数据库]b[Swing的JTable组件...", "content": "仓库地址：github.com/li6in9muyou/SwingDbCrudApp本项目中，使用 Java 的 Swing 组件开发了一个简单的 GUI 应用程序。简单在于其数据流是单向的。数据库中各表的数据填充在一JTable组件中，用户可直接修改各单元格的数据，其改动会被记录到暂存区，要想撤销暂存区中的改动是不能够的。flowchart LRa[数据库]b[Swing的JTable组件]c[暂存区]a --&gt; bb --&gt; cc --&gt; a将程序调试过程中遇到的典型错误列出ArrayStoreException is thrown when putting java.sql.Date into an Object[]Cause: Object[] objects = new String[colCount];Solution:commitObject[] objects = new Object[colCount];custom table cell renderer is not usedCause: class parameter in setDefaultRenderer is not generic enoughSolution:commitchange setDefaultRenderer(String.class, ...) to setDefaultRenderer(Object.class, ...)after reset local tracking branch to HEAD~N, force pushing to remote is rejectedCause: IDE forbids me from doing this not git.Solution: git push --force.Selected rows background are all whiteExpected: blue background, appropriate foreground color for reading.Many cells are unexpectedly painted with highlight color for NULLs and empty stringsExpected: Normal cells background alternates between two colors according to row index andturns blue on focusCause: The same renderer is used to paint many cells. If its internal state is changedwhen rendering one cell, all cells after that is affected.Solution:commitCreate a class that implements TableCellRenderer and holds reference to aDefaultTableCellRenderer. It should return itself if some cell needs special treatment, otherwisereturn that referenced default renderer.Remarks: TableModel in JTable can be strongly typed however DefaultTableModel see alldata as Objects. To use type specific renderer, one must override getColumnClass() ina TableModel.怎么连接到 vmware 虚拟机中的 DB2 数据库？客户机应该使用 NAT 网络模式，在笔者的这个环境中，不能使用 Bridge 模式，因为没有 IP 会被分配给虚拟机。此 NAT 模式下，宿主机的一个网卡接口和客户机的一个网卡接口是在同一个子网。 在虚拟机中用ipconfig命令查看虚拟机的 ip 地址。 使用此地址和 50000 端口号来连接此数据库。怎么让宿主机中的 java 程序连接到虚拟机中的数据库？原资料中的连接方法使用的是 DB2 数据库的 type 2 JDBC 驱动，在宿主机上使用 type 4 JDBC 驱动比较方便。这两中驱动的主要区别是 type 2 驱动依赖于操作系统的原生二进制，type 4 则不需要，因其纯 Java 实现。这几种驱动的说明见此链接。 用你最喜欢的依赖管理器，从 maven 仓库中安装 com.ibm.db2.jcc:db2jcc:db2jcc4 库。 在 java 程序中载入 com.ibm.db2.jcc.DB2Driver 驱动类。 用DriverManager.getConnection(\"jdbc:db2://&lt;ip addr&gt;:50000/sample\", \"&lt;user name&gt;\", \"&lt;user password&gt;\")得到一个Connection类实例。注意，在源码中写入用户名，用户密码，和数据库主机地址是非常非常恶劣的行为。比较好的在各编程语言生态中通行的做法是从环境变量中引入这些秘密的值。Java 生态中还有其他的引入秘密的方法。怎么显示详细的出错信息先尝试在 JDBC 连接字符串中设置 retrieveMessagesFromServerOnGetMessage 属性为真，此后，捕获到 JDBC 驱动抛出的异常时，使用 getMessage() 就可以得到详细的错误说明。示例如下：public static class Program { private final static Connection con = DriverManager.getConnection( \"jdbc:db2://192.168.245.128:50000/sample:\" + \"retrieveMessagesFromServerOnGetMessage=true;\", \"student\", \"student\" );}如果显示的不是中文，则需使用如下方法，手动查询中文简体字的错误说明。也许可以在数据库后台设置本地化策略集为中文简体以免去下面描述的步骤。 捕获 JDBC 驱动抛出的异常。 强制将此异常类型转换为 com.ibm.db2.jcc.DB2Diagnosable，再调用 getSqlca() ，得到一个 DB2Sqlca 对象。 作如下查询，查询字符串为 values (sysproc.SQLERRM(?, ?, ';', 'zh_CN', 1))，第一参数设置为字符串\"SQL%s\".formatted(Math.abs(sqlca.getSqlCode()))，第二参数设置为sqlca.getSqlErrmc()示例如下：public static class Program { private final static Connection con; public String fetchErrorMessage(Throwable error) { // CAUTION! sqlca may be null due to run-time cast. DB2Sqlca sqlca = ((DB2Diagnosable) error).getSqlca(); PreparedStatement query = con.prepareStatement( \"values (sysproc.SQLERRM(?, ?, ';', 'zh_CN', 1))\" ); query.setString(1, \"SQL\" + Math.abs(sqlca.getSqlCode())); query.setString(2, sqlca.getSqlErrmc()); ResultSet rs = query.executeQuery(); rs.first(); return rs.getString(1); }}关于这种做法的详细说明见Handling an SQLException under the IBM Data Server Driver for JDBC and SQLJ。TODO本节内容正在迁移到GitHub Issues 页面。 即使在程序启动时连接数据库失败，也要能够提示连接失败并让用户可以重试。 Fetch 中的修改数据库状态的各方法用模版方法模式重构，主要是为了保证将缓存设置为失效。 Fetch 中发送请求的的各方法用模版方法模式重构，主要是为了处理异常和警告。 显示跟查询命令关联的警告，比如删除时指定的谓词查询不到任何行。 改各功能暂存区的文本框为 JTable。 Fetch::createRows() 里面硬编码了 employee 表的元数据，要查看其他数据表时该怎么办？ TableModel、Fetch中的缓存究竟该用什么类型？怎么处理这两处地方和数据表这三处地方类型转换？ 新功能：重置已经暂存了的单元格的修改。 编译为 WASM 使之能够运行在浏览器中，能否在 Azure 上部署类似的数据库实例？。 修正：批处理的查询出错时，不能显示详细的错误信息。 增强：强力区分处理 Fetch 中的 SQL 异常和 Java 异常，Java 异常的 errorMessage 并不十分有描述性，必须带上error.toString()。 修正：创建多行时若日期类型的列以空字符串为参数，在Fetch::fetchErrorMessage中，Db2Diagnosable::getSqlca 会返回 null。 Multimedia queries 功能：切换数据表，处理原硬编码的仅适用于 employee 表的代码。 重构：如何修改能使代码适应面向多媒体数据的表查询？ " }, { "title": "棋牌类手机游戏项目反思。Review of the Kingz project", "url": "/posts/review-of-kingz-project/", "categories": "ProjectExperience", "tags": "review", "date": "2022-11-01 00:00:00 +0800", "snippet": "本项目是 H5 移动应用开发技术课程的作业，我们计划开发一个双人联机实时对战的棋牌类手机游戏。我在此项目中负责系统设计和主要编码工作。我决定用开发面向移动用户的 web 应用，给出了前端组件的功能设计和整体结构设计，并给出了后端 API 接口定义。经过漫长的开发阶段，我们小组很多成员对我们的最终作品不太满意。我也认为这一项目非常失败。概要本项目前端的几乎全部代码都由我完成，就编码工作而言，其...", "content": "本项目是 H5 移动应用开发技术课程的作业，我们计划开发一个双人联机实时对战的棋牌类手机游戏。我在此项目中负责系统设计和主要编码工作。我决定用开发面向移动用户的 web 应用，给出了前端组件的功能设计和整体结构设计，并给出了后端 API 接口定义。经过漫长的开发阶段，我们小组很多成员对我们的最终作品不太满意。我也认为这一项目非常失败。概要本项目前端的几乎全部代码都由我完成，就编码工作而言，其最大的特点是反反复复的重头开始，当我对目前的实现不满意时总想重新开始重头再来。此外一个很大的弊端是面向过程编程，除了游戏实体外，我没有对诸过程设计抽象。所使用的开发框架也未有此支持，我甚至认为是裸金属风格的开发。面向过程编程我采用了一种基于事件总线的写法，任何实体都可广播消息，任何实体都可以注册一些监听的事件，并提供事件回调函数。这种方法是规定了系统内各个组件之间的沟通方式，我觉得这本身没有什么特别好或者特别坏的地方。但我感觉我的实现很不对劲。首先是，有很多事件纯粹是为了做客户端路由的功能，然后是事件之间有隐式的依赖。最后是如果在React.useEffect里面注册事件订阅函数的话React.StrictMode会在开发环境调用两次，生产环境调用一次。这种一次两次的切换，会导致整个系统的行为有变化，甚至有错误。这个问题虽然能轻易的解决但是我认为这表示我的系统设计得并不好。纯粹为了切换页面切换页面这个事情本来就关系全局，各组件都使用同一个全局变量是必须的。我觉得不好的地方在于，我把切换页面的监听函数和其他业务逻辑写到了一起，这让源码很混乱，代码的内聚程度低，不相干的东西被拼凑到一起。期望的写法是，在不同的文件中、组件中、模块中监听同样的事件，做不同的事情。// fileOne.tseventBus.subscribe(\"eventOne\", change_page);// fileTwo.tseventBus.subscribe(\"eventOne\", save_game_state);现在的写法是，全部都写到一起。// fileOne.tseventBus.subscribe(\"eventOne\", () =&gt; { change_page(); save_game_state();});组件之间的隐式依赖最简单的例子是订阅某事件的函数调用，必须得在发布这个事件的函数调用之前执行。如果这两个函数调用就在上下两行，这种隐式依赖容易被发现。但如若不然，这种软件错误比较难被发现，而且也未必能被一致地复现。这个例子在本项目中就出现了，其背景是在系统初始化的阶段中，有连续多个向事件总线订阅事件的函数调用。其中有的事件处理回调函数会发布新的事件。这些在事件回调中发布的新事件，有的就还没有订阅者。示意如下eventBus.subscribe(\"first\", () =&gt; eventBus.publish(\"second\"));eventBus.subscribe(\"second\", some_critical_function());在上面的代码段中，如果事件总线像下面这样顺序同步地来实现，some_critical_function()是不会被调用的。function publish(event) { for (const subscriber of subscribersOf(event)) { subscriber(event); }}我采用的解决方法是如果某个事件没有订阅者， 就先把这个事件放到一个等待区，等到这个事件的第一个订阅者订阅时再把等待区中的时间全部交给他处理。反复重头开始下面简要列出重头到尾，我做过的失败的开发尝试： tk2：2022-04-23 做了 5 个小时，游戏，React，对游戏、棋盘、玩家的兵力、玩家都作了抽象。 tk3：没有版本控制，React，游戏，对游戏、棋盘、玩家的兵力、玩家、游戏过程作了抽象，写了单元测试，主要是游戏规则和地图生成部分。 tk4：08-30 到 10-03，Svelte，游戏，采用 Clean Architecture，对游戏逻辑、交互界面、网络模块作了抽象，写了单元测试。 tk4-explanation：09-01 和 02 两天，Vanilla，注册、游戏、存档，用了事件总线写法、最简陋的图形界面。 tk5：没有版本控制，Svelte，明显是为了解决 tk4 中太复杂，方法调用太多的问题，缩短了调用链，取消了很多不必要的类、接口等。 tk6：10-13 不到 1 个小时，Vanilla，手动渲染 HTML 标记语言，引入了事件总线的写法，没有实现任何功能。 tk7：10-14 到 10-31 ，React，写了其他非游戏内容，玩家注册、云端保存的游戏、等待匹配、游戏，用的是事件总线的写法，写的是井字棋。 tk8：没有版本控制 ，Backbone，没有实现任何功能，只是为了了解这个框架。 tk9：1024 和 25 两天 ，Django，除了框架自带的玩家注册功能，实现了两人对弈，创建房间，房间列表等，最简陋的图形界面。我认为反复重头开始是因为缺少前期的设计，凭感觉编码，一段事件之后才发现捉襟见肘。编码错误多，添加新的功能困难，出现很多意料不到的错误。但这一个判断，好像也很难从 git 历史中找到依据。使用 git 的习惯不好对一个 commit message，有很多无关的改动，或者说看不出有的改动怎么就跟这个 commit message 有关。例如这个 commit，说是实现了”prompt enter nickname before game start”，但从 diff 看，这只是把控制游戏生命周期的函数调用沿移到原调用链下移。没有任何跟用户交互有关的内容。每一个 commit message 都带一个 label 似乎也不好，因为我还想 commit 很多中间步骤，这些中间步骤单个看其实没有什么作用可笑代码摘编 在条件分支谓词之前保证该谓词为假，见此提交。" }, { "title": "如何用GitHub Actions自动构建并发布一个静态页面。How to build and publish a static web page with GitHub Actions", "url": "/posts/howto-auto-pulish-a-static-site-with-build-process/", "categories": "HowTo", "tags": "github-actions", "date": "2022-10-27 00:00:00 +0800", "snippet": " create a file /.github/workflows/deploy_gh_pages.yml, with following content add vite config entry base: /${githubRepoName}/, note leading and trailing slashesname: deploy_gh_pageson: push: ...", "content": " create a file /.github/workflows/deploy_gh_pages.yml, with following content add vite config entry base: /${githubRepoName}/, note leading and trailing slashesname: deploy_gh_pageson: push: branches: [\"main\", \"master\"]jobs: build: runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 - uses: actions/setup-node@v3 with: node-version: 20 cache: \"npm\" - run: | npm install npm run build - uses: peaceiris/actions-gh-pages@v4 with: github_token: $ publish_dir: ./dist" }, { "title": "计算机图形学上机实验课作业。Computer graphics up machine assignments", "url": "/posts/cg-up-machine/", "categories": "ProjectExperience", "tags": "computer-graphics, algorithm", "date": "2022-10-27 00:00:00 +0800", "snippet": "THIS IS A WORK-IN-PROGRESS模拟从几何到像素点的全过程 给出场景的几何定义 顶点着色器 图元装配 剪裁 透视除法 栅格化，此步骤之后开始引入 frame buffer。 隐面消除，用背向面消除和 z-buffer 方法 顶点属性插值 片段着色器 点亮像素点软件系统设计，绘图器API 设置顶点 设置顶点着色器和片段着色器计划从零开始实现。基本思路...", "content": "THIS IS A WORK-IN-PROGRESS模拟从几何到像素点的全过程 给出场景的几何定义 顶点着色器 图元装配 剪裁 透视除法 栅格化，此步骤之后开始引入 frame buffer。 隐面消除，用背向面消除和 z-buffer 方法 顶点属性插值 片段着色器 点亮像素点软件系统设计，绘图器API 设置顶点 设置顶点着色器和片段着色器计划从零开始实现。基本思路是用高分辨率的画布模拟低分辨率的画布，使用 setPixel 原语绘图。点亮屏幕像素时，在高分辨率的画布上绘制无边框的，单色填充的正方形。题目要求的二维图形绘制较为简单，且相似性很大，绘制多边形、矩形、圆形、贝塞尔曲线其实都是同一个功能。顶点处理阶段片段处理阶段栅格化的目的在于给最终要渲染的像素分配三维坐标和顶点属性，没有这两个信息就没办法决定一片像素的颜色。每一个图元栅格化之后我们得到一批片段，这些片段的几何数据和顶点属性是通过插值得到的，并且是离散的。这些片段未必与最后的像素一一对应，对于每个片段，我们至少需要如下信息： 在空间中的哪一个点 所在图元的每个顶点的顶点属性 深度数据软件系统设计，功能选择菜单需求构建如下三个层次结构的菜单 图形应用 图形绘制 绘制矩形 绘制圆形 区域填充 绘制多边形，用文字填充 三维变换 绘制一个三维立方体 沿 X 轴方向平移 沿 Y 轴方向平移 沿 Z 轴方向平移 绕 X 轴旋转 绕 Y 轴旋转 绕 Z 轴旋转 绘制曲线 绘制贝塞尔曲线 用超链接和静态页面来实现，要实现下面的这个菜单，注意菜单的三个层次结构：每个功能的页面 当前的功能是哪一项 固定的使用说明，由实验课题目给出 例如，点击第一次设置圆心，第二次设置半径 摁a键向 X 轴负方向平移，摁l键向 X 轴正方向平移 参数设置，如果有 颜色，绘制矩形、圆形、多边形填充时需要，是一个 RGB 颜色值。 平移步长、旋转度数，是一个实数。 画布 用 canvas 绘制 手工模拟像素点，逐像素点上色 " }, { "title": "项目经历汇总。Projects I've made", "url": "/posts/projects-overview/", "categories": "ProjectExperience", "tags": "", "date": "2022-10-26 00:00:00 +0800", "snippet": "THIS POST IS WORK-IN-PROGRESS基础理论和算法 TCP 可靠传输协议实现，处理丢包、乱序、超时问题，用 C++。 三维渲染管线实现，还原三维渲染过程，实现经典三维图形算法，如 Phong shading、SMAA 等，用 JavaScript。 互斥锁的实现，实现四种经典算法，在浏览器 WebWorker 之间自行实现共享内存，用 Svelte。 某算法比赛...", "content": "THIS POST IS WORK-IN-PROGRESS基础理论和算法 TCP 可靠传输协议实现，处理丢包、乱序、超时问题，用 C++。 三维渲染管线实现，还原三维渲染过程，实现经典三维图形算法，如 Phong shading、SMAA 等，用 JavaScript。 互斥锁的实现，实现四种经典算法，在浏览器 WebWorker 之间自行实现共享内存，用 Svelte。 某算法比赛，实现了点云表面重建、多 Agent 遍历图等，用 C++。 不围棋自动下棋程序，团队合作，负责文档和设计，用 C++。 光线追踪渲染在一个周末，用 Go。 某大学编译器课程，编写一个面向对象语言（COOL）的编译器，用 flex、bison 等工具，用 C++。前端 图书搜索、筛选、收藏功能演示，用 Svelte 在线井字棋，设计了双人对战平台通信协议，用 React FreeCodeCamp 前端开发证书要求的几个项目，着重前端业务逻辑和状态管理，用 Vanilla JS 和 Svelte XML、XSL 编辑器，实用工具，网页编辑器，带实时渲染和本地保存，用 Vanilla JS 公共留言板，数据库部署在 PocketHost，任何人可留言，管理员可验证身份， 用 Vanilla JS 后迁移至 Svelte。Java 聊天网站开发，用 Java EE、Spring Boot。 直接使用 JDBC 驱动开发 CRUD 桌面应用，用 Swing P2P 双人对战游戏桌面应用，用 Swing团队协作 基于 Git 的小型开发团队，撰写需求分析和架构设计等文档，测试驱动开发，模仿Electron 架构开发一桌面 P2P 双人对战游戏基本操作学习 基于 libuv 服务器开发 基于 Compose 的安卓开发流程云服务和 CI/CD 多个仓库都使用 GitHub Action 将站点自动部署到 GitHub Pages、腾讯云、Azure 本博客在云端构建之后部署到 Azure 用 PocketHost 部署 SQL 数据库，其他项目通过 RESTful API 使用 熟悉 Linux 和 Bash 基本操作 笔者按：以下是旧的内容，仅作存档。神机妙算算法竞赛 2021-07-31为了锻炼自己解决陌生领域软件问题的能力，我参加了这一神机妙算算法竞赛。竞赛主办方要我在 C++的运行环境下完成竞赛给出的三个题目。这些题目的情景我很陌生，我尝试将题目抽象为学过的基本算法模型和基本的数据结构，在此基础上通过阅读相关的论文和查找并整合现有的函数库及工具包等尝试解决这些问题。最终我剥离了一庞大代码库中的部分算法，用别的数据结构库中的代码补充其依赖以此解决了其中一个问题，另外两个问题则是根据论文的描述自己实现了算法。社交平台系统模拟设计 2021-12-21这是 C++程序设计课程的编程作业，为了锻炼自己设计和实现复杂系统的能力，我决定不仅要实现功能还要在前期仔细地设计，要实现自动化测试脚手架。我被要求设计并模拟实现一个即时聊天软件，要具备一对一聊天、群聊、单平台多服务等功能。我设计并实现了该平台的多个子系统，包括用户身份、聊天服务、数据存储、用户内容管理、用户交互等，给出了各子系统的功能要求和公共接口。后来就在此基础上进行了编码实现。在系统的用户交互界面子系统中，我还设计了基于文件流的自动测试脚手架。从这个项目的编码过程中，我发现我的设计是远远不足够的，不够详细。并且我对软件开发工作流程也不掌握。常常一边编码一边修改设计、增加功能需求，导致工作越做越多。番茄钟 2021-05-14我刚开始学习前端开发，计划用 UML 课程中的概念和方法以及 Clean Architecture 来设计这一简单的应用。这个应用的端到端测试已经给出，这是一个简单的单页应用，我计划使用 Svelte 框架进行开发。我进行了简单的设计，规范了组件之间数据和事件的流向，给出了组件之间的公共接口。这一项目顺利完成，我熟悉了 Svelte 框架的使用。重构多人在线游戏演示程序 2021-06-12为熟悉 Clean Architecture 设计原则，我尝试用此结构重构一多人在线游戏的演示程序。我必须先读懂原程序的功能和结构，抽象出用例，再用目标结构的语义复现它们。我设计并实现了领域模型类以及实现各用例的服务类，满足了预先的用例规约。在此过程中我发现并修复一常见的导致无限循环的编码错误，即在一本应只读实体状态的函数内修改了这一实体状态，而这一实体状态的修改又会触发原先读这一实体状态的操作。不围棋下棋程序 2022-04-18组队开发不围棋游戏的自动下棋程序。我的任务是在阅读文献和资料的基础上，综述计算机下棋程序的开发思路。并在开发的同时撰写设计报告。我阅读了 MIT 的人工智能导论课程中有关计算机博弈的内容，并分析了 GitHub 上的常见计算机博弈算法的实现，最后我建议使用现有的MCTS 框架来开发。我在设计报告中给出了所开发的算法的描述和说明，并评估了这些策略在对局中表现。本组作品被教授评为优等。互斥锁的软件实现的演示程序 2022-10-10这是大学操作系统课程的编程作业，我选择这一题目因其简单明了。我要开发一个具备图形化用户界面的互斥锁软件实现的演示程序，需给出各争抢进程的运行状态。我采用 Svelte 开发。用 web worker 实现了程序的平行执行，为了避免在浏览器中使用SharedArrayBuffer，我借用一种分布式存储算法来实现了web worker 之间的共享内存。我进行了多次大规模重构，实现了具备较高可扩展性的软件系统。这一程序功能丰富，界面简单易用，被教授评为优等。棋牌类多人在线对战手机游戏开发 2022-11-01本项目是 H5 移动应用开发技术课程的作业，我们计划开发一个双人联机实时对战的棋牌类手机游戏。我在此项目中负责系统设计和主要编码工作。我决定用开发面向移动用户的 web 应用，给出了前端组件的功能设计和整体结构设计，并给出了后端 API 接口定义。经过漫长的开发阶段，我们小组很多成员对我们的最终作品不太满意。我也认为这一项目非常失败。" }, { "title": "组队开发联机对战游戏：炸飞机。bomb airfield game", "url": "/posts/bomb-airfield-game/", "categories": "ProjectExperience", "tags": "teamwork, c#", "date": "2022-10-26 00:00:00 +0800", "snippet": "小队成员中都不太熟悉 dotnet 语言生态也不熟悉基于 git 的合作开发模式，我负责系统的整体设计和部分子系统的开发，我给出了系统各模块的接口设计，并跟小队成员分享了 git 和 GitHub 的常见使用方法，最终小队各成员都熟悉了 git 的常用操作并在时间期限前完成了开发任务。 本文是设计文档，该开发过程的反思在此链接。炸飞机炸飞机游戏逻辑类本类负责实现游戏逻辑，并提供当前的游戏状...", "content": "小队成员中都不太熟悉 dotnet 语言生态也不熟悉基于 git 的合作开发模式，我负责系统的整体设计和部分子系统的开发，我给出了系统各模块的接口设计，并跟小队成员分享了 git 和 GitHub 的常见使用方法，最终小队各成员都熟悉了 git 的常用操作并在时间期限前完成了开发任务。 本文是设计文档，该开发过程的反思在此链接。炸飞机炸飞机游戏逻辑类本类负责实现游戏逻辑，并提供当前的游戏状态给需要查询的其他模块，游戏状态表示如下。 飞机摆法列表：一个列表，里面各元素记录有机头坐标和飞机朝向。 系统猜想的敌方飞机的摆法：一个列表，里面各元素记录有机头坐标和飞机朝向。 本方机场挨炸：一个列表，装有挨炸位置的坐标。 我方炸对方机场得到的结果：一个列表，里面各元素记录有坐标和炸的结果。修改上述的游戏状态是不会改变游戏逻辑类内部的游戏状态的。设计思路游戏中有两个机场，一个摆有自己飞机的机场，另一个用来记录炸对手机场的结果。对手机场上飞机的摆法本方客户端是不可见的。数据类包括：存有 3 个飞机头+方向的 AirplanePlace 类（单例）可实例化的“飞机头+方向”的 Airplane 类（非单例）本方机场被炸的坐标集，BeBombed、（单例），用 HashSet 存一系列坐标点敌方机场被炸的坐标集+状态，OpponentAirfield（单例），用什么类型的数据结构还不知道一些约定：飞机原点坐标约定为左上角(0,0),x➡ 右增，y⬇ 下增本方机场图像状态=飞机头坐标+方向+被炸的坐标集（分别在 AirplanePlace 和 BeBombed 类中。需要写算法计算具体状态，已经保证不会越界/重叠）敌方机场状态=坐标+状态（都在 OpponentAirfield 类中）1、摆飞机（坐标，上、下、左、右）：怎么用?实例化一个游戏逻辑类对象（GameLogic 类），不断调用其中的方法 setAirplane(int x,int y,String d),若传入成功，返回 bool 类型的 true，若传入不成功，则可能是（飞机机头/机身坐标越界、重叠），需要提示用户，返回 false里面的算法逻辑：1）、机头/机身坐标是否越界2）、获取已有飞机坐标，判断是否有飞机坐标重叠返回 bool 值public class Coordinate{ public int X; public int Y; public Coordinate(int x, int y); public static Coordinate Void();}2、本方机场挨炸（坐标）：返回炸的结果，未炸中、炸中了机身、炸中了机头。炸的结果使用 C# 枚举类。public enum BombResult{ Miss, Hit, Destroyed}3、登记炸对方机场的结果（坐标，炸的结果）：炸的结果同上条。将敌方返回的结果登记在代表敌方机场的数据结构中4、我的飞机全部被摧毁了吗（）：返回是或否。调用此函数，若返回 ture，则说明此场比赛本方输，敌方获胜，若 ture，则向敌方发送”认输”包此外，此函数必须在 2、本方挨炸方法 的调用之后使用5、导出当前游戏状态（）：供读者读取游戏状态，具体表示见上文。导出的结果是一个 GameStateSnapShot，里面有敌方机场坐标+状态，我方机场飞机坐标+方向，我方机场被炸的坐标+状态实现细节设计使用单例模式来保证只有一个实例。网络模块炸飞机协议炸飞机协议的语法以 EBNF 描述如下，协议语义按照上边非终端符号的英文名字的意思来理解就可以了。协议时序定义见下文顺序图的描述。game = handshake, player ready, [{message}], game over;message = coordinate | bomb result ;bomb result = \"miss\" | \"hit\" | \"destroy\";handshake = digit, digit;game over = \"end\";yield = \"yield\";continue = \"continue\";player ready = \"ok\";coordinate = digit, \",\" , digit;digit = \"0\" | \"1\" | \"2\" | \"3\" | \"4\" | \"5\" | \"6\" | \"7\" | \"8\" | \"9\";做一个网络沟通交流类，提供一个读取数据的接口，供炸飞机协议类使用。public interface ICommunicator{ bool IsLostConnection(); string Read(); string Expect(Regex expected); void Write(string message); void Start(); void Stop();}炸飞机协议类这个协议类规定了两个炸飞机游戏客户端之间的互动。 通知对手我已经摆好飞机（） 等待对手摆好飞机（） 阻塞，直到远端客户端发来飞机已经摆好的信息。可能会等很久，对手要摆完他的飞机。 炸对方的机场并返回炸的结果（坐标）：炸的结果 等待对方来炸我方机场（）：坐标 发回我方机场挨炸的结果（炸的结果） 等待通知对手我方没有输（） 等待向对方认输（） 等待对方认输（）：如果对方不认输，返回假，否则返回真基于 TCP 流的网络类有如下 TCP 特有的方法： 创建房间（）：IP 地址 加入对方房间并等待和对手握手（IP 地址）：我方是否先手 这个方法抛出异常 CanNotJoin 如果没办法加入的话。 等待对手加入（）：我方是否先手等待类操作的异常事件处理方法网络超时对方玩家操作超时交互界面模块绘制本地玩家败北（）绘制本地玩家胜利（）等待用户决定是否在本房间中继续下一局（）：是或否用户选择否的话整个程序退出。选择是的话，稍后游戏主程序将调用交互界面模块里面的等待用户摆好自己的飞机方法。绘制其他内容（其他内容） 聊天信息 开发调试信息 通知消息 对手的 IP 地址是……、对手已加入房间 对手正在摆飞机 对手正在选定要炸的位置 对手已经离线 绘制游戏数据状态（游戏逻辑类实例）等待本回合用户要炸的对方机场的坐标（游戏逻辑类实例）：坐标阻塞，最多等待 30 秒，从进入这个方法开始计时，如果用户没有输入就返回 (-1,-1)。本方法接受一个游戏逻辑类实例的目的是为了避免用户重复炸已经炸过的地方。等待用户摆好自己的飞机（游戏逻辑类实例）阻塞。传入一个游戏逻辑类，用来判断用户的摆法是不是合理，交互界面类应该调用摆飞机（……）方法，直到摆好三架。之前的方案是规定交互界面类不能直接修改游戏逻辑类，在之前的方案中，此方法仅仅是获取飞机摆法而不实际摆飞机，但有可能摆了第一架飞机之后，返回的列表中的后面两架飞机的摆法会违反规则。等待获取一个 IP 地址（建议的值）：IP 地址阻塞，如果用户希望创建房间的话就返回空字符串。传入一个建议的值可以实现记忆上次对战的玩家的功能。人工智能模块本回合要炸的对方机场的坐标（游戏逻辑类实例）：坐标推断对方飞机的摆法（游戏逻辑类实例）：飞机摆法列表返回值定义见上文。游戏流程整个程序流程各子系统初始化询问玩家如何联机两个客户端握手并分出先后手while ( true ) { 游戏主循环 通知对手游戏结果 通知用户本轮游戏的结果 如果用户选择退出 两个客户端关闭连接 跳出循环}系统退出游戏主循环自己玩家摆飞机通知对方自己已经摆好并等待对方玩家摆好while ( !本地玩家输了 ）{ 通知对方我方没有输并等待回应 如果对方回应他输了，跳出循环 如果是本方回合 等待UI传回本方玩家要炸的坐标 传给远端并等待回应 更新游戏状态 否则 等待远端发来坐标 查询炸的结果 返回炸的结果 切换到另一个玩家的回合}游戏各子系统初始化sequenceDiagramparticipant main as 主函数participant ui as 界面类participant socket as 网络类participant game as 数据类activate mainmain -&gt;&gt; ui : 初始化main -&gt;&gt; socket : 初始化main -&gt;&gt; game : 初始化在线游戏功能初始化sequenceDiagramparticipant main as 主函数participant ui as 界面类participant socket as 网络类participant remote as 对方炸飞机客户端main -&gt;&gt; ui: 获取一个IPactivate uiui --&gt;&gt; main: IP address（加入别人的房间）或者空字符串（成为房主）deactivate uialt 房主main -&gt;&gt; socket: 创建房间（）activate socketsocket --&gt;&gt; main: 本房间的IP地址deactivate socketmain -&gt;&gt; ui: 绘制其他内容（IP地址）activate uiui --&gt;&gt; main: voiddeactivate uimain -&gt;&gt; socket: 等待对方加入（）activate socketdeactivate socketelse 加入房间main -&gt;&gt; socket: 加入对方房间并等待和对手握手（IP 地址）activate socketdeactivate socketendactivate socketsocket --&gt;&gt; remote: 建立连接或等待连接remote --&gt;&gt; socket: 握手数据包socket --&gt;&gt; main: 我方是先手还是后手deactivate socket游戏准备阶段sequenceDiagramparticipant main as 主函数participant ui as 界面类participant socket as 网络类participant game as 游戏逻辑类participant remote as 远端炸飞机客户端main -&gt;&gt; ui: 等待用户摆好自己的飞机（游戏逻辑类实例）activate maindeactivate mainactivate uiui --&gt;&gt; main: voiddeactivate uiloop 三架飞机，循环三次activate mainmain -&gt;&gt; game: 摆飞机（飞机摆法）deactivate mainactivate gamegame --&gt;&gt; main: voiddeactivate gameendactivate mainmain -&gt;&gt; socket: 等待对手摆好飞机()deactivate mainactivate socketsocket --&gt;&gt; remote: 飞机已经摆好remote --&gt;&gt; socket: 飞机已经摆好socket --&gt;&gt; main: voiddeactivate socketactivate maindeactivate main炸飞机阶段本游戏规定两个玩家轮流丢炸弹。到自己的回合可以丢一个炸弹，丢完一个炸弹后变为对方回合。回合由主函数协调，一开始是根据网络模块握手的结果给定谁丢炸弹，此后每当收到对方机场挨炸的结果就切换一次回合。我方等待对手来炸，对手的回合。sequenceDiagramparticipant main as 主函数participant ui as 界面类participant socket as 网络类participant game as 游戏逻辑类participant remote as 远端炸飞机客户端main -&gt;&gt; ui: 绘制其他内容（需等待对方选定炸的位置）activate maindeactivate mainactivate uideactivate uiactivate mainmain -&gt;&gt; socket: 等待对方来炸我方机场（）deactivate mainactivate socketremote --&gt;&gt; socket: 坐标socket --&gt;&gt; main: 坐标deactivate socketactivate mainmain -&gt;&gt; game: 本方机场挨炸（坐标）activate gamedeactivate maingame --&gt;&gt; main: 炸的结果deactivate gameactivate mainmain -&gt;&gt; socket: 发回我方机场挨炸的结果（炸的结果）activate socketdeactivate mainsocket --&gt;&gt; remote: 炸的结果deactivate socketmain -&gt;&gt; ui: 绘制游戏数据状态（游戏逻辑类实例）activate mainactivate uideactivate uideactivate main我炸对方机场，我的回合。sequenceDiagramparticipant main as 主函数participant ai as 人工智能类participant ui as 界面类participant socket as 网络类participant game as 游戏逻辑类participant remote as 远端炸飞机客户端main -&gt;&gt; ui: 查询用户是否开启AI代玩（）activate maindeactivate mainactivate uiui --&gt;&gt; main: 是或否deactivate uialt 不开启AI代玩main -&gt;&gt; ui: 等待本回合用户要炸的对方机场的坐标（游戏逻辑类实例）activate maindeactivate mainactivate uiui --&gt;&gt; main: 坐标deactivate uielse 开启AI代玩main -&gt;&gt; ai: 本回合要炸的对方机场的坐标（对方机场的炸的结果）activate maindeactivate mainactivate aiai --&gt;&gt; main: 坐标deactivate aiendactivate mainmain -&gt;&gt; socket: 坐标deactivate mainactivate socketsocket --&gt;&gt; remote: 炸对方的机场并返回炸的结果（坐标）remote --&gt;&gt; socket: 炸的结果socket --&gt;&gt; main: 炸的结果activate maindeactivate socketactivate mainmain -&gt;&gt; game: 登记炸对方机场的结果（坐标，炸的结果）deactivate mainactivate gamedeactivate gameactivate mainmain -&gt;&gt; ui: 绘制游戏数据状态（游戏逻辑类实例）activate uideactivate uideactivate main游戏胜负已分sequenceDiagramparticipant main as 主函数participant game as 游戏逻辑类participant ui as 界面类participant online as 网络类participant remote as 远端炸飞机客户端main -&gt;&gt; ui: 本局对战已经结束请选择退出房间或者再来一局（）activate maindeactivate mainactivate uiui --&gt;&gt; main: 再来一局、退出房间deactivate uialt 再来一局activate mainmain -&gt;&gt; online: 和远端握手分出先后手()deactivate mainactivate onlineonline --&gt;&gt; remote: 握手数据包remote --&gt;&gt; online: 握手数据包online --&gt;&gt; main: 我方是先手还是后手deactivate onlineactivate maindeactivate mainelse 退出房间activate mainmain -&gt;&gt; online: 退出房间deactivate mainactivate onlineonline --&gt;&gt; remote: 断开连接remote --&gt;&gt; online: 断开连接online --&gt;&gt; main: voiddeactivate onlineactivate maindeactivate mainend" }, { "title": "用Go编写一个解释器 Write an interpreter in go", "url": "/posts/write-an-interpreter-in-go/", "categories": "Learning", "tags": "compiler, go", "date": "2022-10-17 00:00:00 +0800", "snippet": "THIS POST IS WORK-IN-PROGRESSI am using this book “Writing An Interpreter In Go” by Thorsten Ball.You can but this book at https://interpreterbook.com/.In the meantime, I amtaking this free coursea...", "content": "THIS POST IS WORK-IN-PROGRESSI am using this book “Writing An Interpreter In Go” by Thorsten Ball.You can but this book at https://interpreterbook.com/.In the meantime, I amtaking this free courseat edx.org.Test Driven DevelopmentThis book advocates a TDD approach. Some tests could be tedious to write, so I copy them from the book.And I wrote tests to reproduce bugs and verify implementation details.testing package provides very limited functionality. You have to write your assertions explicitly, likepeek, _ := lex.peekChar()if peek != \"=\" { t.Fatalf(\"expected=%q, got=%q\", \"=\", peek)}It would be nice to haveexpect(peek).toEqual(\"=\");I will find a library to do that for me.LexerLexer and parser have a very common behavior. Both of them will peek one character/token then decide which concretelexer/tokenizer to use. Some tokens may start with the same character. For example, let and latitude both startswith character l but they are keyword and identifier respectively. So when character l is encountered a lexer wouldtry to use a sequence of “sub-lexers” according to some predefined priority. When one “sub-lexer” fails, it tries thenext one. An example is given below.word := lexer.eatWord()t, err = lexer.tryKeyword(word)if err == nil { return t, err}t, err = lexer.tryIdentifier(word)if err == nil { return t, err}ParserA parser parses tokens into abstract syntax trees. Parsing is one of the most well-understood branches of computerscience and really smart people have already invested a lot of time into the problems of parsing.I will implement a “Pratt parser” or “top down operator precedence parser”from regex to NFAsimple onesThe following content is covered in section 04-03 of that edx courseFor regex literal or epsilon movesstateDiagramdirection LR[*]--&gt;[*]: regex literal or epsilonFor ABstateDiagramdirection LR[*]--&gt;A: epsilonA--&gt;B: epsilonB--&gt;[*]: epsilonFor A + B. In regex (and in C# spec below), this means A|B.stateDiagramdirection LR[*]--&gt;A: epsilon[*]--&gt;B: epsilonA--&gt;[*]: epsilonB--&gt;[*]: epsilonFor A*flowchart LRstt[start]--epsilon--&gt;AsttAstt[enter A]-.-&gt;Aend[exit A]Aend--epsilon--&gt;fin[end]Aend--epsilon--&gt;sttLet’s try implementingC# spec for real literalsfragment Decimal_Digit : '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' ;fragment Decorated_Decimal_Digit : '_'* Decimal_Digit ;Real_Literal : Decimal_Digit Decorated_Decimal_Digit* '.' | Decimal_Digit Decorated_Decimal_Digit* Exponent_Part? Real_Type_Suffix? | '.' Decimal_Digit Decorated_Decimal_Digit* Exponent_Part? Real_Type_Suffix? | Decimal_Digit Decorated_Decimal_Digit* Exponent_Part Real_Type_Suffix? | Decimal_Digit Decorated_Decimal_Digit* Real_Type_Suffix ;fragment Exponent_Part : ('e' | 'E') Sign? Decimal_Digit Decorated_Decimal_Digit* ;fragment Sign : '+' | '-' ;fragment Real_Type_Suffix : 'F' | 'f' | 'D' | 'd' | 'M' | 'm' ;error handlingError occurs when current token is different from what the parser expects. For now, this parsersimply adds descriptions of such mismatch to an array.parse statementslet statement ensure there is a LET token try parse an identifier ensure there is an equal sign try parse an expressionfunc (parser *Parser) tryLetStatement() (ast.LetStatement, error) {\tvar err error\tstmt := ast.LetStatement{}\tstmt.Token = parser.currentToken\tparser.eatToken()\tstmt.Name, err = parser.tryIdentExpr()\tif err != nil {\t\treturn stmt, err\t}\tparser.eatToken()\terr = parser.tryAssignOp()\tif err != nil {\t\treturn stmt, err\t}\tparser.eatToken()\t// parse an expression, not implemented yet.\treturn stmt, nil}Steps above closely resemble a let statement literal.return statement ensure theres is a RETURN token try parse an expressionfunc (parser *Parser) tryReturnStatement() (ast.ReturnStatement, error) {\tstmt := ast.ReturnStatement{}\tstmt.Token = parser.currentToken\tparser.eatToken()\t// parse an expression, not implemented yet.\treturn stmt, nil}parse expressionsidentifier expressionTo parse this expression, simply eat one Token.Its value is that token’s literal.integer literal expressionTo parse this expression, simply eat one Token.Then call strconv.Atoi to get its numerical value.type IntegerLiteral struct {\tToken token.Token\tValue int}prefix operator expressionprefix_expr := prefix_op expr" }, { "title": "互斥锁的实现：软件方法 Implementation of software mutex locks", "url": "/posts/software-mutex-simulation/", "categories": "ProjectExperience", "tags": "mutex, javascript, svelte, frontend, JLU-assignment, concurrent-programming, threads, algorithm", "date": "2022-10-15 00:00:00 +0800", "snippet": "See it live at live demoI built a simple app to demonstrate the execution of 4 algorithms that solved the mutex problem. The mutex problem is toensure that only one of many concurrently running pro...", "content": "See it live at live demoI built a simple app to demonstrate the execution of 4 algorithms that solved the mutex problem. The mutex problem is toensure that only one of many concurrently running processes is executing the critical region. Being a software solutionmeans that it requires no special hardware or special instructions e.g. test-and-set, compare-and-swap.The four algorithms I was asked to implement are: Lamport’s bakery algorithm Dekker’s Peterson’s Eisenberg &amp; McGuire’sFeatures Each (simulated) process can be paused and resumed during execution Global memory is updated in real-time Line number of source code at which the process is executing is updated in real-timeBackgroundThis app simulates a scenario where many processes are contending a lock. These algorithms implements lock()and unlock() routines for such a lock. All four algorithms uses some shared memory, e.g. wants_to_enter and turnin the following snippet.async function lock(...) { wants_to_enter[pid] = TRUE; while (TRUE === wants_to_enter[counterpart(pid)]) { if (turn[0] !== pid) { ... } }}By definition, shared memory means that all processes are able to observe modifications made by other processes.Typically, lock() routine of these algorithms only writes to a same memory index, e.g. pid, and occasionallyiterates over all elements in memory.Implementation Considerationsconcurrent executionThe JavaScript runtime is single-threaded thus to achieve concurrent execution in the browser is not straight forward.This problem is solved by spawning web workers which are mapped to real operating system threads.abandoned approach: emulating CPUAnother approach would be to emulate CPU in one thread. This approach requires all four algorithms to be compiled intosome sort of “assembly language” so that code can be broken up into pieces. By switching between “contexts”, parallelexecution can be achieved.For example, the following JavaScript code// original JavaScript codewants_to_enter[this.who] = Dekker.TRUE;while (Dekker.TRUE === wants_to_enter[this.counterpart(this.who)]) { if (turn[0] !== this.who) { wants_to_enter[this.who] = Dekker.FALSE; while (turn[0] !== this.who) { // busy waiting } wants_to_enter[this.who] = Dekker.TRUE; }}can be compiled to[ Store(\"wants_to_enter\", pid, TRUE), JumpIfNotEqual(\"wants_to_enter\", pid, TRUE, 7), JumpIfEqual(\"turn\", 0, pid, 6), Store(\"wants_to_enter\", pid, FALSE), Noop(), JumpIfNotEqual(\"turn\", 0, pid, 4), Store(\"wants_to_enter\", pid, TRUE),];The above assembly is compiled manually. Dekker’s algorithm is the simplest one among them but compiling its codealready requires a lot of tedious work. The approach is quickly abandoned.busy waitsBusy waits likewhile (should_wait(...)) { // busy wait}are exploited extensively in all four algorithms. Due to the nature of mutex problem, the condition that processes waiton is not going to change it’s that process’s turn to enter critical region. In another words, these busy waits waits along time. A naïve implementation of busy wait consumes all computing resource of single CPU core which is bad. Thingsget worse when there are multiple processes contending the same critical region.This problem is solved by awaiting a promise inside all busy wait loops. Waiting a promise effectively frees up the CPUso that the event loop will be able to pick up other tasks.while (should_wait()) { await sleep(1);}observe and command processestracing hooksIn order to report one process’s progress to UI sub-system, we can have them emit tracing events when executing. To dothat, tracing function calls must be added in the algorithm implementation. The following example is the lock()routine of the Peterson’s algorithm. break_point(...) is tracing call which is named breakpoint because this call canpause function execution as well.async function lock(...) {... for (let i = 1; i &lt; victim.length; i++) { await break_point(1); await break_point(2); level[pid] = i; await break_point(3); victim[i] = pid; await break_point(4); do { await break_point(100); await Yield(); ... } while (!can_proceed(pid, i, level, victim)); await break_point(5); await Yield(); }...}In side break_point function call, it emits a LineNumber event.const LineNumber = (lineno: number) =&gt; ({ type: \"lineno\", payload: lineno,});const Pre = () =&gt; ({ type: \"pre\" });const Post = () =&gt; ({ type: \"post\" });const Running = () =&gt; ({ type: \"running\" });Similarly, processes emit tracing events before and after critical region.async (...) =&gt; {... emit(Running()) await lock_impl(...); emit(Pre()); await critical_region(); emit(Post()); await unlock_impl(...); emit(Completed());}pause a processPausing a process can be implemented as blocking at a function call or enter an idle loop. Utilizing the await semanticsin JavaScript, I designed the following implementation to pause a running async function.The execution of a lock() routine is paused when it awaits on a promise that is controlled by master thread. Thispromise is created when a pause request is received and is fulfilled when a resume request is received. lock() routineof Lamport’s algorithm is shown below.async function lock(...) {... flag[pid] = TRUE; await break_point(1); label[pid] = max(label) + 1;...}Statements for setting two elements is separated by an await statement where it’s going to waiting on the _pausepromise inside call to break_point(). request_resume() and request_resume() is typically called from masterthread.function request_resume() { shouldPause = true; _pause = new Promise((resolve) =&gt; { _resolve = () =&gt; { shouldPause = false; return resolve(null); }; });}Pausing flag shouldPause along with _pause is set or cleared when a pause request is received. Naturally, _resolveis called when a resume request is received.function request_resume() { if (shouldPause &amp;&amp; !isUndefined(_resolve)) { dbg(`resume ${_i}`); return _resolve(null); } dbg(`this process is not paused`);}shared global memoryData exchange between master thread and worker threads is extremely limited. And worker threads can not directly accessmemory used by master thread.the easy way: ShardArrayBufferOne solution to this problem is touse SharedArrayBuffer.When pass such objects to multiple workers, they can access the same underlying ArrayBuffer hence any updates tothat SharedArrayBuffer is visible to all worker threads. However, to enable SharedArrayBuffer HTML document needs tobe in a secure context. This “secure context” thing, in my scenario, boils down to setting two header entries at theserver side. At first, I promptly set this up and call it a day. But later I realize that my page will be served onGitHub Pages where I can not set the response header entries. So I devised another approach.the hairy way: broadcast writesAnother approach would be manually syncing all memory writes. Every process sends its write requests to a centralizedbroadcaster. Upon receiving any write requests, the broadcaster broadcasts this request to all the other processes. Whenreceiving write requests from other processes, process updates its local copy of global memory.This approach eliminates the need for special headers and it can be employed in simple static web pages. I think thisapproach has a name in the field of distributed programming but I have not identified it yet.flowchart TBA[\"Process#z, [0,89,0,0]\"]---&gt;|set index 1 of some_array to be 89, please|BroadcasterBroadcaster---&gt;|set index x of some_array to be y, please|Process#a[\"Process#a, [0,0,0,0]\"]Broadcaster---&gt;|...|Process#b[\"Process#b, [0,0,0,0]\"]Broadcaster---&gt;|...|Process#c[\"Process#c, [0,0,0,0]\"]Inevitably, local copies of individual processes will be stale from time to time but that’s ok because these 4algorithms are all designed to work under such conditions. In fact, there is no ground truth for a global memory withthis approach. Should there be any communication issues, i.e. packet lose, processes will never agree with each otherany more. Furthermore, this approach is not easily scalable with numerous messages being passed around. Despite theseshortcomings, it’s good enough for this particular application.In practice, all processes subscribe to an observable in master thread and a broadcaster in master thread subscribe toall processes.In master threadprocess.source.subscribe((args) =&gt; { if (isWriteRequest(args)) { this.processes.map((process) =&gt; process.update(args)); }});And in simulated process’s code, we update local copy on every writefunction update(ev) { const [slice, index, arr] = ev; local_copy[slice][index] = arr;}General DesignOperations on a simulated process can be categorized as a command e.g. pause or a query e.g. whether it’s in criticalregion. UI subsystem subscribes to event source provided by an adapter and updates UI accordingly. Users resume/pauseprocesses through IProcessComand.IProcess and IProcessGroupSimulated process is modeled by two interfaces as follows:interface IProcessQuery { pid: number; execution_state: Observable&lt;ProcessLifeCycle&gt;; program: IProgram;}interface IProgram { locking_state: Observable&lt;LockingState&gt;; line_number: Observable&lt;number&gt;;}interface IProcessCommand { start(): Promise&lt;void&gt;; resume(): Promise&lt;void&gt;; pause(): Promise&lt;void&gt;; kill(): Promise&lt;void&gt;; set_breakpoint(to_be: boolean): Promise&lt;void&gt;;}Shared memory is attached to a group of contending processes. Furthermore, IProcessGroup is used to pause/resume allprocesses at the same time.Finally, a process group is modeled as follows. Note that IProcessGroup.pid and IProcessGroup.all implementsthe IProcessCommand interface hence UI subsystem commands them transparently.interface IProcessGroupQuery { execution_state: Observable&lt;ProcessLifeCycle&gt;[]; program: IProgram[]; memory: Map&lt;string, Observable&lt;Array&lt;number&gt;&gt;&gt;;}interface IProcessGroup { all: IProcessGroupQuery &amp; IProcessCommand; pid(pid: number): IProcess; process_count: number;}Note that type Observable used above is nothing more than an interface with a simple subscribe(subscriber) method.It’s a rather generic and universal concept so I suppose it’s ok to put it in interfaces without limiting implementationat any way.In IProcessGroupQuery, memory is modeled as a Map&lt;string, ...&gt; where its keys are names of shared objects used inalgorithm implementations. UI sub-systems consumes this interface by subscribing to every item in this Map object andupdates when events are emitted.Implementation DetailsUI subsystemUI is built with svelte." }, { "title": "如何给本站添加文章", "url": "/posts/howto-write-a-post/", "categories": "HowTo", "tags": "chore", "date": "2022-10-15 00:00:00 +0800", "snippet": "严禁在本博客抖机灵，所有内容必须清楚表达意思。steps Clone this repo from GitHub Create a post under /_posts/. See “A Post” section below for details Commit then push.expected behavior: The push to GitHub kicks off a ...", "content": "严禁在本博客抖机灵，所有内容必须清楚表达意思。steps Clone this repo from GitHub Create a post under /_posts/. See “A Post” section below for details Commit then push.expected behavior: The push to GitHub kicks off a sequence GitHub Actions The new post is live at the site A small commitlike thistakes about one minute from push to live.A Postfile nameFile names of posts should be &lt;YEAR&gt;-&lt;MONTH&gt;-&lt;DAY&gt;-&lt;title&gt;.md where title should a sequence of hyphen separated ASCIIwords.File names will be used in links, non-ASCII character would be unreadable after URL encoding.Blank spaces are replaced with hyphen automatically by Jekyllgood:2022-10-17-howto-write-a-post.mdbad:2022-10-17-howto write a post.md2022-10-17-如何添加文章.mdfront matterThe front matter must be the first thing in the file.example:---title: 如何给本站添加文章categories: [HowTo]tags: [chore]---For anything else, refer to Jekyll doc.fields title: blog title. Use any character you want date: ADD THIS FIELD IF YOUR MUST. this field override dates in file name categories: CamelCase category name, [CategoryOne]. Using multiple category names means sub-categorye.g. [Animal, Mammal] tags: list of kebab-case tag names, [tag-one, tag-two]image assetsWhen possible, use mermaid-js to generate graphs.Images should be in /assets/blog-images. Links in markdown should have prefix /assets/blog-images.FIXMEThe set up above would cause markdown editor to be unable to locate and render images. This behavior is not desirable. Iam working on a better solution.other guidelines Markdown titles and subtitles are used to generate permalink, use concise ACSII titles if you don’t want your linkends up to be gibberishlike example.com/posts/%E5%A6%82%E4%BD%95%E7%BB%99%E6%9C%AC%E7%AB%99%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0 YAML syntax requires a space after colon,see this commit Do not use unidecode characters in image url,see this commit Do not hard code links to blog posts, use {&lt;percent sign&gt; post_url 2022-10-15-howto-write-a-post &lt;percent sign&gt;}.Thiswhole thing will get replaced with correct link at blog build time. coming soon…" }, { "title": "移动应用设计和开发：棋牌类手机游戏", "url": "/posts/kingz-mobile-tk2/", "categories": "ProjectExperience", "tags": "react, frontend, teamwork", "date": "2022-10-03 00:00:00 +0800", "snippet": "本文是本项目的设计文档，反思见此文。待办任务 PR#1 缺陷：游戏标题页如果“填入网名”宽度不够换行，会导致旁边的“点击随机生成”按钮下半部分全部是空白。预期是按钮高度跟左边没换行时一样，不要出现文字下面有大量的空白。 增强：远端玩家离线时，现在有两个选项，1 我也不玩了 2 重新匹配，添加一个选项为 3 跟本地电脑接着玩。 重构：GameOver.jsx 中 winner === \"...", "content": "本文是本项目的设计文档，反思见此文。待办任务 PR#1 缺陷：游戏标题页如果“填入网名”宽度不够换行，会导致旁边的“点击随机生成”按钮下半部分全部是空白。预期是按钮高度跟左边没换行时一样，不要出现文字下面有大量的空白。 增强：远端玩家离线时，现在有两个选项，1 我也不玩了 2 重新匹配，添加一个选项为 3 跟本地电脑接着玩。 重构：GameOver.jsx 中 winner === \"local\" 被用来判断本地玩家的输赢，这很不好。可以考虑拆分成三个事件，即本地赢了、本地输了、平手。 重构：evInitGameState 和 evUpdateGameState 非常令人困惑，为什么第一次游戏状态更新这么特殊？我觉得应该可以改成对局生命周期事件。前端功能需求下面用线框图展示典型交互过程。每个方框就是对应一个用户看到的页面，其中也包含了对该页面上视觉元素的粗略设计，仅供参考。下图类似 UML 所讲的状态图，箭头表示在页面之间跳转，箭头上的文字标注表示发生了的行为。初始状态显然是 Kingz 游戏标题页，最后也会回到这里。要注意的是，这里的箭头并没有被穷尽地列出。前端的设计我们的前端应该划分为一些【零件】，这些零件用发布和订阅事件来跟其他零件交互。这些零件要向作为全局变量存在的唯一的【事件总线】实体订阅自己感兴趣的事件，并通过这一实体发布事件。 笔者按，零件是抽象组件或者模块的意思，不用组件是避免跟各种前端框架里的组件混淆。例如：等待中页面就可以订阅匹配到了、取消匹配、匹配失败等事件，事件发生时这些零件做相应的事情，需要的话可以通过事件总线来发布消息。为了区分各种消息，每个消息都要有一个type字段。如果要给订阅者提供信息，还需要带上一个的数据块，也就是下面的payload字段。示意如下：{ type: 类型; payload: 数据块;}前端流程概览flowchartstt[客户端主界面]stt--&gt;b{从历史对局开始\\n或新对局}fin[得到棋局token]b--&gt;|用户从历史对局中选择一个|客户端查询用户在云端存储的对局--&gt;用户选择一个--&gt;finb--&gt;|用户选择匹配对手|客户端请求云端分配一个棋局token--&gt;finfin--&gt;在线游戏适配器向云端查询棋局状态--&gt;在线游戏适配器发布云端更新游戏状态事件--&gt;init{游戏适配器判断\\n本地游戏状态\\n是否完成初始化}init--&gt;|已初始化|游戏适配器更新本地游戏状态--&gt;游戏适配器发布游戏状态更新事件--&gt;视图层根据事件中数据更新视图--&gt;游戏适配器发布把游戏状态推送到云端事件--&gt;在线游戏适配器向云端推送数据init--&gt;|未初始化|游戏适配器初始化本地游戏状态--&gt;游戏适配器发布游戏状态初始化事件--&gt;视图层根据事件中数据更新视图用户输入自己的游戏招数--&gt;视图层发布本地玩家出招事件--&gt;游戏适配器更新本地游戏状态前端事件规约零件：主界面前置要求：无stateDiagram-v2state \"要求用户输入网名\" as unregstate \"欢迎你\" as reg[*] --&gt; unreg: props.registered === false[*] --&gt; reg: props.registered === trueunreg --&gt; [*]: 用户提交新输入的网名\\nemit evSubmitNewNickname(nickname)reg --&gt; [*]: 用户决定查看存档\\nemit evMySavedGame()reg --&gt; [*]: 用户开始游戏\\nemit evStartNewGame()零件：用户的历史对局stateDiagram-v2state \"列出历史对局\" as d[*]--&gt;dd--&gt;[*]: 用户选定存档\\nemit evResumeSavedGame(save_idx)d--&gt;[*]: 用户返回\\nemit evBackToGameTitle()零件：选择跟电脑玩或者匹配玩家前置要求： 玩家网名stateDiagram-v2state \"询问要跟电脑对战还是跟玩家匹配\" as s[*] --&gt; ss--&gt;[*]: 跟电脑玩\\nemit evStartLocalComputerGame()s--&gt;[*]: 跟玩家匹配\\nemit evStartMatching()零件：匹配中WaitingInQueue.jsx前置要求： 玩家网名，本机指纹，本页面等待GameHttpClient的结果，如果回报失败则显示失败页面，询问玩家是否继续等。每次进入此页面或者玩家决定继续等，都要发布开始查询匹配状态的事件。stateDiagram-v2state \"等待中\" as Astate \"汇报匹配失败了\" as B[*]--&gt;A: emit evStartPollingMatchStatus()A--&gt;[*]: 用户取消匹配\\nemit evCancelMatching()A--&gt;B: recive evCloudDeclineMatchB--&gt;A: 用户决定继续等\\nemit evStartPollingMatchStatus()B--&gt;[*]: 用户决定跟电脑玩\\nemit evCancelMatching()\\nemit evStartLocalComputerGame()零件：棋盘页前置要求： 能够构造出当前棋盘状态，如下方式之一 有棋盘初始状态和双方玩家的招数 或者：当前棋盘状态 等待初始棋盘，如果是在线匹配，要等双方玩家都收到同一个棋盘后才可以继续，如果是本地游戏，则由相应游戏进行生成。stateDiagram-v2state \"等待初始棋盘\" as prestate \"游戏正在进行\" as inGamestate \"等待对手出招\" as waitRemotestate \"汇报游戏胜负\" as gameOver[*]--&gt;prepre--&gt;inGame: receive evInitGameState(game_state)waitRemote--&gt;inGame: receive evUpdateGameState(game_state)inGame--&gt;waitRemote: 用户输入他的招数\\nemit evLocalMove(game_move)inGame--&gt;gameOver: receive evGameOver(winner)gameOver--&gt;[*]: 用户点击回到主界面\\nemit evBackToGameTitle()inGame--&gt;[*]: 用户退出或保存退出\\nemit evLocalQuit()\\nOR evLocalSaveThenQuit()上图中的事件：负责游戏通信的公共代码发布： evRemotePlayerWentOffline()具体的游戏发布： evInitGameState(game_state) evUpdateGameState(game_state) evGameOver(winner)具体的游戏订阅： evLocalMove(game_move)React 组件层级设计classDiagramGamePage o-- InGameGamePage o-- WaitingForInitGameStateGamePage o-- GameOverInGame o-- GameViewclass GameView {useContext GameStateemit evLocalMove(game_move)}class InGame {props GameViewemit evLocalQuit()emit evLocalSaveThenQuit()}class GamePage {props GameViewcreateContext GameStatereceive evGameOver()receive evInitGameState()receive evUpdateGameState()}class GameOver {props.winneremit evBackToGameTitle()}零件：对手离开了对局stateDiagram-v2state \"汇报对手离开了对局\" as remoteQuit[*]--&gt;remoteQuitremoteQuit--&gt;[*]: 用户决定保存退出\\nemit evSaveGameState(game_state)remoteQuit--&gt;[*]: 用户决定重新匹配\\nemit evSaveGameState(game_state)\\nemit evStartMatching()前端的公共代码在页面之间保存的状态class LocalStore { player_id: string; secret: string; nick_name: string; match_handle: string;}对局匹配器此实体负责： 发出匹配请求 反复查询匹配状态 取消当前的匹配请求在线对战适配器游戏逻辑实现设计如下图。GameAgentAdapter 跟 ConcreteGame 紧密合作，ConcreteGame中保存有游戏的状态，它由 GameAgentAdapter 实例化，并可被初始化为一个外部给定的初始状态。没有其他实体可以修改 ConcreteGame 中的游戏状态。游戏状态通过发布事件来传递给其他子系统。注意到，OnlineGameAdapter 包装的是通讯协议，是跟游戏无关的。此模块负责把游戏状态更新发送给云端，并在云端有状态更新时通知客户端。在此简单的设计中，此模块使用反复请求云端最新状态的方法来检查游戏是否有更新。classDiagramclass ConcreteGameclass GameAgentAdapterGameAgentAdapter --&gt; ConcreteGameclass IGameAgent {&lt;&lt;interface&gt;&gt;init(event_bus, game_state)handleLocalMove(move)handleCloudUpdate(game_state)}GameAgentAdapter ..|&gt; IGameAgentOnlineGameAdapter ..|&gt; IRemoteAgentclass IRemoteAgent {&lt;&lt;interface&gt;&gt;attach_event_bus(event_bus)close()async push_state_to_cloud(game_state)}前端的实现任务实现本地人机对战功能基本思路是让电脑玩家的实现提供一个IRemoteAgent接口。整合现有游戏代码步骤如下： 为新游戏编写视图层代码，即一个 React 组件来把它渲染到网页中。 用一个适配器类实现IGameAgent接口。Kingz 战棋游戏状态的序列化规定interface SerializedKingzGameState { token: string; // 棋局ID data: string[][]; // 下面描述的二维数组 roundIdx: number; // 一个整数表示当前回合数}二维 JSON 数组中每个元素用一个字符串，格式为[a-z][n,a,b][0-9]{1,4}，第一个小写字母表示地块的类型，第二个表示归属，后面的数字表示兵力数量。兵力数量就是一个整数。地块类型： m (ountain) 障碍物 e (mpty) 空地 f (ortress) 堡垒 h (ome) 基地。归属： n (eutral) 中立 a 其中一个玩家 b 另一个玩家编写公共代码事件总线这一个实体大致实现下面这个接口，emit 就是发布事件的意思，on 就是用来订阅某个事件和事件处理函数的。为了调试的方便，要求在控制台记录所有发布出来的事件，以及调用了哪些订阅者。interface Observable { publish(ev: { event_type: string; payload: any }): void; subscribe( event_type: string, subscriber: (ev: { event_type: string; payload: any }) =&gt; void ): void;}组件间路由路由的意思就是在页面之间切换。这一实体侦听一种定义好的路由事件，按照需要更换显示出来的页面。按照云端 API 封装客户端代码编写一个【云端请求类】把对这些 API 的请求写进这个类的各种方法中去，以便各页面中的代码来调用。设计下面这些方法都可能发送网络请求，所以都是异步的，如果有没有预料到的 http 错误，会抛出异常。OnlineIdentity该类负责用户的注册和在线身份的管理，包括有如下方法 register(nickname:string):Promise&lt;OnlineHandle&gt; 用一个网名来注册，返回一个在线句柄。 fetch_local_identity():Promise&lt;OnlineHandle|null&gt; 查询本机有没有注册，如果localStorage没有就向云端查询，都没有就返回 null KingzHttpClient此处设计未更新 构造函数(onlineHandle) fetch_my_games():Promise&lt;GameState[]&gt; 从云端或者localStorage获取GameState的列表，供残局对战使用 fetch_init_game(matchHandle):Promise&lt;GameState&gt; try_match():Promise&lt;MatchHandle&gt; push_local_state(localState):Promise&lt;Promise&lt;GameState&gt;&gt; 异步地返回一个 Promise，里面有云端的状态 编写各个页面的代码这里说的页面就是上面图中的方框，对每个页面要做这些操作： 考虑要不要把跟它有频繁关系的页面归并在一起，编为一个零件。如果没有那就是一个零件渲染一个页面 罗列出这一个零件需要订阅的事件以及要发布的事件，给出数据块的定义，如果有。 编码实现。云端功能需求云端应该是游戏无关的，客户端给云端发送一个游戏状态和一个版本号。客户端和云端的版本号都是从零开始。云端保证各个客户端之间的版本号最多只相差一。例如interface Data { version: number; game_state: any;}为了启用跨站请求，云端发回的 http 回复的头部中应设置 Access-Control-Allow-Origin 为如下值中之一。如果 http 请求头部中的 origin 项的值不是下面三个之一（注意第一个有通配符），云端可拒绝这个请求。Access-Control-Allow-Origin: \"*.li6q.fun\"Access-Control-Allow-Origin: \"li6q.fun\"Access-Control-Allow-Origin: \"li6in9muyou.github.io\"查询此玩家保存的棋盘路径：GET /saved_games/{玩家ID}返回格式如下{ idx: \"存档的id\"; match_token: \"棋局token，同下面的定义\";}获取玩家句柄路径：GET /player_handle根据给定的 nickName 和 secret， 返回一个玩家 ID，要求是p[0-9A-Z]{12}。secret，不能为空，必须是满足 regex[0-9A-Z]{8}。nickName，不能为空，云端限制一个合理的长度。客户端使用如下请求：axios.get(\"/player_handle\", { params: { secret: \"浏览器指纹abcd1234\", nickName: \"勇敢的小明\", },});异常事件流如果有某项为空或者没有这个键，就返回 400 bad request。请求开始匹配路径：POST /match/{玩家ID}axios.post(\"/match/somePlayerHandle\", { match_handle: \"既有棋局的token\",});给这个玩家一个棋局，保证有一个对手，但是还没有棋盘状态。这个棋局可以是全新的棋局，也可以是残局。如果请求请求正文中带有一个非空的棋局 token，且这个棋局 token 跟这个玩家句柄是关联的，则返回同一个棋局 token，表示接受此玩家从残局开始匹配对手；否则，返回一个不同的棋局 token，表示给玩家一个新的棋局。询问匹配状态路径：GET /match/{棋局token}/{玩家ID}/opponent客户端拿到棋局 token 后会反复请求这个地址，每个客户端每 1 秒请求一次，收到一次success 后就不再请求这一个棋局 token 的匹配状态了。返回一个字符串就行，下面三种情况 成功(success) 失败(fail) 等待(waiting)玩家中途取消匹配路径：DELETE /match/{玩家ID}/这个玩家取消匹配了，解开此玩家 ID 和此前棋局 token 的绑定。请求云端的游戏状态路径：GET /match/{棋局token}/{玩家ID}返回的格式interface MatchPayload { version: number; // 这个游戏状态的版本号 game_state: any; // 游戏状态}异常事件流token不存在就返回 404，和空 body。这个玩家不属于这个棋盘就返回 404，和空 body。客户端推送它的状态到云端路径：PUT /match/{棋局的token}/{玩家ID}格式跟上面的返回格式一样，含义也一样。异常事件流token不存在的话就返回 404。roundIdx小于或者等于云端的话就抛弃不理会。玩家退出这个对局路径：DELETE /match/{棋局的token}/{玩家ID}云端解除这个玩家和这个棋局的关联。返回空 body，200 状态码就行。异常事件流token 或者 ID 没有的话就返回 204云端时间进度这部分由刘某某组织设计，由祁某某和刘某某编码实现。开发进度记录在 GitHub 上查看提交记录第八周 正在落实零件间交互的细节设计 界面设计和实现全部完成 正在编写对局匹配功能第九周 合并了队员刘某的提交 客户端功能基本完成 正在迁移正式的游戏到系统中 云端功能已启动" }, { "title": "重构代码练习。apply clean architecture on a python tutorial codebase", "url": "/posts/apply-clean-architecture-on-a-python-tutorial-codebase/", "categories": "Learning", "tags": "socket, python, clean-architecture", "date": "2022-06-12 00:00:00 +0800", "snippet": "What are we buildingIn this tutorial on implementing multiplayer online game in pygame, the presenter Tim developed a two player online game where local player moves a square on the screen with key...", "content": "What are we buildingIn this tutorial on implementing multiplayer online game in pygame, the presenter Tim developed a two player online game where local player moves a square on the screen with keyboard the the position of the square controlled by a remote player is synced via a custom designed communication protocol based on TCP.The communication protocol is outlined below: when a client connects to the server, it’s assigned with an id. First client connects to the server gets a id of 0, the other gets 1. when client sends the coordinates of its player to the server, server replies with the coordinates of the other player. The format used here is &lt;id&gt;:&lt;x&gt;,&lt;y&gt;, for example, 0:50,60 which means client with id of 0 reports that its square is at coordinates (50,60).Initial state of the codebaseBefore game loop starts, the Game object creates two Player instances and Canvas instance. In the game loop, the Game object checks whether relevant keys are pressed then calls Player.move on the instance that represents the local player. After handling inputs, it syncs the coordinates of the other Player with the server.# Game.runif keys[pygame.K_RIGHT]: if self.player.x &lt;= self.width - self.player.velocity: self.player.move(0)if keys[pygame.K_LEFT]: if self.player.x &gt;= self.player.velocity: self.player.move(1)if keys[pygame.K_UP]: if self.player.y &gt;= self.player.velocity: self.player.move(2)if keys[pygame.K_DOWN]: if self.player.y &lt;= self.height - self.player.velocity: self.player.move(3)# Send Network Stuffself.player2.x, self.player2.y = self.parse_data(self.send_data())# Update Canvasself.canvas.draw_background()self.player.draw(self.canvas.get_canvas())self.player2.draw(self.canvas.get_canvas())self.canvas.update()Notice that Game calls Player.draw to draw sprites on the screen.My refactoringIn short, this game models two sprites moving in an arena.Domain ObjectsDomain objects includes Arena and Player.Arenaclass Arena: def __init__(self, width, height, players): self.players = players self.width = width self.height = height self.ground_color = (255, 255, 255)Playerclass Player: def __init__(self, init_x=-1, init_y=-1, color=(100, 100, 100)): self.color = color self.x = init_x self.y = init_y self.velocity = 2 def move(self, direction): ...Use casesThe primary use cases are user may press keyboard to move its square the position of other user’s square is updated in real timeI designed ArenaMoveService to implements these two use cases..player_move(player, direction)For the first use case, ArenaMoveService.player_move(player, direction) mutates Player object passed in and calls self.port.dump(self.arena, self.players) to output game state.def set_coord(self, player, x, y): def clip(value, upper, lower=0): if value &gt;= upper: return upper if value &lt;= lower: return lower return value player.x = clip(x, self.arena.width) player.y = clip(y, self.arena.height) self.port.dump(self.arena, self.players).set_coord(player, x, y)For the second use case, due to limitation of the communication protocol, moving direction of the remote player is not conveniently known, ArenaMoveService.set_coord(player, x, y) directly sets one sprite’s coordinates. Moving directions of the remote player can be obtained by differencing last known position and the latest position. Calculate its moving direction then calls Player.move on the remote player’s sprite is a better approach because it will ensure two sprites move in consistent manner.def player_move(self, player, direction): if direction == 0: if player.x &lt;= self.arena.width - player.velocity: player.move(0) if direction == 1: if player.x &gt;= player.velocity: player.move(1) if direction == 2: if player.y &gt;= player.velocity: player.move(2) if direction == 3: if player.y &lt;= self.arena.height - player.velocity: player.move(3) self.port.dump(self.arena, self.players)AdaptersExternal actors of this system includes a local user and a remote user.Considering the loop-based nature of this video game system, I designed the interface of adapters as follows:interface IAdapter { on_update(elapsed: number): void; on_init(context: Context): void;}IAdapter.on_update will be called on every rendering cycle.KeyboardInputAdapterIt checks key presses then call AreneMoveServiedef on_update(self): keys = pygame.key.get_pressed() if keys[pygame.K_RIGHT]: self.arena_move_service.player_move(self.player, 0) if keys[pygame.K_LEFT]: self.arena_move_service.player_move(self.player, 1) if keys[pygame.K_UP]: self.arena_move_service.player_move(self.player, 2) if keys[pygame.K_DOWN]: self.arena_move_service.player_move(self.player, 3)OnlineAdapterIt sends position of local player’s sprite and updates that of remote player’s.def on_update(self): data = f\"{self.local_player_id}:\" \\ f\"{self.local_player.x},{self.local_player.y}\" self.client.send(str.encode(data)) self.arena_service.set_coord(self.remote_player, *self.parse_data(self.client.recv(2048).decode()))PortsIn this system, the only port is PyGameRenderPort that render sprites to the screen. In the following code, arena and players captures the entire game state.PyGameRenderPortdef dump(self, arena, players): self.screen.fill(arena.ground_color) for player in players: pygame.draw.rect( self.screen, player.color, (player.x, player.y, 50, 50) ) pygame.display.update()ThoughtsInfinite Recursion BugexpositionIn effect, the OnlineAdapter is responsible for both sending local state to server and updating local copy of remote state. The first responsibility ports system state to a external actor while the second mutates system state and invokes method on ArenaMoveService.Hence, component with these two responsibilities may be considered a “port” as well as an “adapter”. At first, I decided to put it in an output port, like so:def dump(self, *_): data = f\"{str(self.id)}:{str(self.local_player.x)},{str(self.local_player.y)}\" self.client.send(str.encode(data)) reply = self.client.recv(2048).decode() self.arena_move_service.set_coord(self.remote_player, *parse_data(reply))Not before long, I discovered that code snippets above causes stack overflow because maximum recursion depth exceeds.analysisI made two mistakes here.For one, this output port is calling a service which violates the clean architecture principles dictating that flow of control should starts from services then points outwards to ports.For another, more generally, when dump() is called, it makes query to system state and subsequently mutates it, which leads to another invocation of dump().solutionOne simple solution to this is to make updates only when something has actually changed. In following code snippets, dump() makes the mutating call conditionally after comparing previous state and current state. I employed this solution at first. def dump(self, *_): data = f\"{str(self.id)}:{str(self.local_player.x)},{str(self.local_player.y)}\" self.client.send(str.encode(data)) now_remote_x, now_remote_y = parse_data(self.client.recv(2048).decode()) if self.prev_remote_x != now_remote_x or self.prev_remote_y != now_remote_y: self.arena_move_service.set_coord(self.remote_player, now_remote_x, now_remote_y) self.prev_remote_x = now_remote_x self.prev_remote_y = now_remote_yAnother solution would be move remote synchronization logic in an adapter where it’s appropriate to call ArenaMoveService as shown above." }, { "title": "PowerShell自动补全", "url": "/posts/powershell%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8/", "categories": "HowTo", "tags": "tooling, PowerShell", "date": "2022-06-06 00:00:00 +0800", "snippet": "THIS POST IS DEPRECATED, SEE POWERSHELL DOTFILEExecute following lines in PowerShell, then restart it.Install-Module PSReadLine -AllowPrerelease -Forceecho \"Set-PSReadLineOption -PredictionSource H...", "content": "THIS POST IS DEPRECATED, SEE POWERSHELL DOTFILEExecute following lines in PowerShell, then restart it.Install-Module PSReadLine -AllowPrerelease -Forceecho \"Set-PSReadLineOption -PredictionSource History\" &gt;&gt; $profileecho \"Set-PSReadLineOption -PredictionViewStyle ListView\" &gt;&gt; $profileshowcasePicture was removed when this post got deprecated." }, { "title": "如何恢复删除掉的文件和照片。How to undelete my pictures?", "url": "/posts/howto-undelete-my-pictures/", "categories": "HowTo", "tags": "chore", "date": "2022-06-05 00:00:00 +0800", "snippet": "I accidentally lost a few folders under D:\\tech--BLOG\\.Failed attempts I need “Windows File Recovery” tool. Go to https://store.rg-adguard.net/ to retrieve direct download links for this tool. Do...", "content": "I accidentally lost a few folders under D:\\tech--BLOG\\.Failed attempts I need “Windows File Recovery” tool. Go to https://store.rg-adguard.net/ to retrieve direct download links for this tool. Download VCLibs runtime and the tool itself In elevated powershell, use Add-AppPackage command to install them. Run command winfr D: C: /regular /n tech--BLOG/ It started scanning disk and appeared to freeze at 99% after around ten minutes. After retrying a couple of times, I quit.Successful ones So I turned to recuva Following clear instructions in GUI prompts, all pictures except two were recovered in seconds." }, { "title": "如何把历史上的post迁移到本站", "url": "/posts/howto-migrate-posts/", "categories": "HowTo", "tags": "chore", "date": "2022-06-05 00:00:00 +0800", "snippet": "THIS POST IS OUTDATED, REFER TO THE LATEST VERSION 添加 front matter。 把源 post 复制到/_posts/，重命名为YYYY-MM-DD-${title}.md的格式。I may leave title as is knowing that chineses characters are preserved in bro...", "content": "THIS POST IS OUTDATED, REFER TO THE LATEST VERSION 添加 front matter。 把源 post 复制到/_posts/，重命名为YYYY-MM-DD-${title}.md的格式。I may leave title as is knowing that chineses characters are preserved in browser’s address bar and white spaces will be automatically replaced with dashes. 如果有，把*.assets文件夹移到/assets/blog-images。 在源 post 中给所有图片链接 prefix /assets/blog-images。" }, { "title": "番茄钟的设计与实现。design of tomato-clock", "url": "/posts/design-of-tomato-clock/", "categories": "ProjectDesign", "tags": "software-engineering, making-things-complicated", "date": "2022-05-14 00:00:00 +0800", "snippet": "domain entitiescountdown-period duration default duration namecounter isRunning shouldLoopcounter has one or more countdown-periodsusecaseresume and pause this event is captured no business ...", "content": "domain entitiescountdown-period duration default duration namecounter isRunning shouldLoopcounter has one or more countdown-periodsusecaseresume and pause this event is captured no business rules isRunning = !isRunning no outputset duration of a countdown-period this event is captured business rules 1 &lt;= duration &lt;= 60 depends on isRunning if isRunning == true, do nothing set the specified countdown-period’s duration. no outputcountdown execute every 1 second depends on isRunning if isRunning == true, increase internal counter by one otherwise, do nothing no outputreset this event is captured no business rules restore initial state isRunning = false for every countdown-period, duration = default duration components/classescountdown-period repositoryIt is a sequence of countdown-period.This class provides a factory methodfromArray(periods: CountDownPeriod[]).It provides whichDuration(time: number): CountDownPeriod which throws NoDurations if sequence is empty. If time is bigger than the sum of durations of all periods, it overflows. It throws InvalidTimeValue if time is negative.countdown-periodThis is a simple value entity representing basic information of periods. Instances are mutated by setDuration(duration: number) and reset. Constructor are fairly simple: ctor(name: string, defaultDuration: number). duration is exposed as public attribute.clockpublic state readonly time: integer the number of seconds elapsed with isRunning being true since this instance is created.methods reset(): call stop(), then set time to 0. start(): set isRunning to true, id = setTimeout(()=&gt;{...}, 1000). stop(): set isRunning to false, clearTimeout(id).controllerthis entity handles aforementioned events." }, { "title": "书单分享项目：反思和批判", "url": "/posts/thoughts-on-book-list-demo-app/", "categories": "ProjectExperience", "tags": "svelte, frontend", "date": "2022-05-09 00:00:00 +0800", "snippet": " 编者按：这是对一个书单分享应用 demo 的反思，项目地址。使用 svelte 开发，持续了一个月。e-library 项目routes.js定义了 URL 字面量到 svelte 组件映射以及页面名字到 URL 字面量的映射，前者是给路由库使用的路由定义，后者是在 HTML 中嵌入链接时使用的常量。每个页面都大致对应系统的一个子系统，调试页则聚合了相关的功能。最初分为如下几个子系统： ...", "content": " 编者按：这是对一个书单分享应用 demo 的反思，项目地址。使用 svelte 开发，持续了一个月。e-library 项目routes.js定义了 URL 字面量到 svelte 组件映射以及页面名字到 URL 字面量的映射，前者是给路由库使用的路由定义，后者是在 HTML 中嵌入链接时使用的常量。每个页面都大致对应系统的一个子系统，调试页则聚合了相关的功能。最初分为如下几个子系统： 书本搜索页 注册 登录 我的书单注册和登录功能最初的注册页，组合了AskPassword和AskDisplayName两个组件并且要求它们返回一个Reable&lt;{value: string}&gt;。这里的返回是以 output parameter 来完成的，使用 svelte 的 bind directive。不过从父组件的角度看，他只需要字符串，整个生命周期只会读取一次 store 中的值。并且注册页组件还负责调用persistUser来将createUser的返回值持久化储存。这几个功能都是由一个UserService包提供的。功能上来看，这个注册页没有考虑 alternative execution path，例如： 用户存在但密码错误 用户不存在以及等待网络回复时也没有反馈给用户，应该 disable UI 按钮的 click handler 并显示 loading spinner，网络回复收到之后要相应地恢复上述这些状态。登录页跟注册页有大量的重复，他们两个都使用AskPassword和AskDisplayName组件。他们的提交按钮的 click handler 中只有“正在登录”vs“正在注册”等字面量有差别。后来我加入了路由系统之后，也是在这个UserLogin组件中直接抛出路由事件来触发路由切换。这个不太好，因为该组件的主要职责是渲染视觉元素。这里要解决的问题就是通知各 interested parties，用户已经成功鉴权了，这边可以用一个全局的 publisher/event-emitter 之类的模式来处理。路由系统监听此事件，收到后便切换到适当的页面。注意到这边说的用户 credential 校验和异常 execution path。用户 credential 校验又可以分为本地校验和云端校验。理想的状态应该是，本地校验应该从 user 包中导入相关的 validator，然后由 UI 组件负责搭建输入框及错误提示等视觉元素，云端校验用抛出异常来提示出错，UI 组件负责把抛出的这些异常渲染成用户友好的视觉元素。书本搜索页本页的主要功能是 显示一批书本 多选及相关功能 关键字匹配 回显错误关键字 回显显示的条数 加入和移出书单 单本书 多本书 一开始时，在CatalogUI 组件中直接访问数据库，代码中有大量的数据库细节。处理全反选清空的逻辑也是写在此处。弊端： UI 组件依赖于其他子系统的实现细节 不同 UI 组件的逻辑写在一起，很难将视觉元素拆开，在视觉层面和在 HTML 层面都很难。关键字匹配的实现方法 规定 Filter 就是 Book 上的 predicate。 父组件暴露一个变量 filter，类型是上述 Filter，初始值为恒真函数，并监听 filter 的赋值事件。 子组件在自己的生命周期中可以反复给上述全局变量赋值。 filter 的赋值事件发生时，父组件把新的 filter 应用到全部的 items，得出新的应显示的条目。显示一批书本在Listing组件中，输入是条目的集合 处理空集的特殊情况，提示用户没有条目 使用VirtualList应付大量的条目，然后调用Entry组件，由该组件负责渲染每一个条目。显示一个条目和选中条目功能Entry组件，负责渲染一个条目，输入有一个条目对象。并依赖由祖先组件设置的两个全局变量： 当前选中的所有条目的集合：这是为了决定是否显示自己为被选中。 toggle 函数：调用它可以设置某本书的选中状态。这里其实很怪，因为完全可以把所有条目的集合改成一个查询某本书选中状态的 query 函数。但即便如此，也不妥当。因为渲染一个条目的组件也可以单独使用，也就是不需要点击切换选中状态这一功能。不应该把实现这一功能的逻辑写在该组件中。同时，这么写的话，这一组件的使用者调用者也根本不知道应提供怎么样的全局变量，调用者一定要知道该组件的实现细节才可以使用，这很不好。" }, { "title": "计算机下棋程序设计，以不围棋为例。", "url": "/posts/nogo-bot/", "categories": "ProjectExperience", "tags": "c++, teamwork, machine-learning", "date": "2022-04-18 00:00:00 +0800", "snippet": " 作者按：这是数据结构课程的 assignment，本人撰写了本设计报告。botzone NoGo 棋简单 AI 的设计小组成员： 李秉权 软件学院 2020 级 6 班 刘小宝 软件学院 2020 级 6 班 刘小明 软件学院 2020 级 6 班 王三金 软件学院 2020 级 10 班1 分工与合作项目进行的初期，刘小明、王三金与 botzone 对战平台上的机器人进行了多次...", "content": " 作者按：这是数据结构课程的 assignment，本人撰写了本设计报告。botzone NoGo 棋简单 AI 的设计小组成员： 李秉权 软件学院 2020 级 6 班 刘小宝 软件学院 2020 级 6 班 刘小明 软件学院 2020 级 6 班 王三金 软件学院 2020 级 10 班1 分工与合作项目进行的初期，刘小明、王三金与 botzone 对战平台上的机器人进行了多次对弈，结合两人具备的围棋基础，向另外两名队员介绍了不围棋的基本知识和博弈思路，分析了这种游戏与传统围棋的异同。而刘小宝与李秉权两人则进行了文献查找和资料查阅的工作，李秉权总结说，机器博弈的关键在于要有前瞻性[1]，计算机不仅要能对当前的博弈状态做静态的分析，还要能够预测对手的行动，综合分析比较过后去争取对双方玩家都是折中的游戏状态。刘小宝则大量观看了不围棋的历史对战回放，他提出我们应该侧重对棋局做静态分析，指出我们应该参考模式识别的基本原理来评估棋局局部对双方的厉害关系，并以此为依据构思了几种对已方有利的棋局模式。项目进行到中期，刘小宝则编码实现了基于棋局局部识别的对弈框架，构思了可选落子位置的静态估值函数的程序接口，并实现了反映必要游戏规则的估值函数作为示例。这为后期队员分头编写功能代码打下了良好的基础。李秉权则对对战平台提供的代码进行了 C++的现代化重构，并整理了常用的程序接口，诸如寻找连通块的气、游戏棋盘的方便输入输出等。此外，李还提出即便我们不了解围棋原理和博弈的基本知识，我们也可以用蒙特卡洛搜索树取得较好的效果，他指出，如果使用他找到的开源搜索树框架我们只需要重写几个关键步骤的实现[2]，就可以使用这一著名算法进行对局，根据[3]，他认为这一算法可以取得较好的成绩。项目进行的后期，根据项目中前期的分析研判，我们决定采用刘小宝提出的基于估值函数的博弈算法，因为这种方法相对简单，符合各组员对不围棋游戏的直觉。我们交流讨论之后每个队员分别领取若干估值函数的编写任务，并分头开始编码工作。各队员所承担的编码任务都在四月十五日之前基本完成了。其中，具体的任务记录如下： 队员 完成的编写工作 刘小宝 程序主要逻辑框架、必要的各数据结构、部分估值函数（填眼） 李秉权 部分估值函数（与现有同色棋子连成眼、与现有同色棋子连成线） 刘小明 部分估值函数（填眼、构造平行四边形的第一步、构造平行四边形的第二步） 王三金 部分估值函数（棋局的四角、利于构建居于棋局四角的三角形） 第一阶段的编码工作完成后，由王三金在 botzone 平台上进行了多轮对战，他记录了几种程序常出现的反常行为，并对算法的参数进行了调整，决定从棋局中期开始降低青睐填眼和构造平行四边形的估值函数的权重，刘小明对新的参数进行测试，注意到我们的机器在 20 局之后的构造出的活棋的气的数量由原来的一至三提高到了五至七个。这个过程中李秉权则发现并修正了程序的一处缺陷。我们认为各成员承担的工作量如下： 成员 百分比 刘小宝 40% 刘小明 20% 李秉权 20% 王三金 20% 由李秉权撰写了本实验报告。2 参考文献与创新之处除上面提到的文献外，在项目的前期阶段，我们了解了常见的计算机下棋解决方案，以及围棋基本知识。在编码实现方面，除了老师统一提供的程序示例之外，其他所有代码都是我们队伍分工编写了的，只有部分的思路借鉴了网络上的文献和其他资料。 [1] Search: Games, Minimax, and Alpha-Beta. MIT OpenCourseWare. https://youtu.be/STjW3eH0Cik [2] C++ MCTS. Konijnendijk. https://github.com/Konijnendijk/cpp-mcts [3] NoGo Bot. https://fstqwq.pw/nogo-bot/3 算法思想概括地说，我们开发过程可以概括为如下两个步骤： 根据实践经验（empirical experience）和领域内知识（domain knowledge），归纳大量的实践观察总结棋局的共性得出操作性强的启示。 将前述专业域内启示，以一个或一组估值函数的形式表达出来，并编码实现，这一过程是我们的工作的主要内容。具体地说，算法如下：每次决策都先遍历每一个棋盘上的符合规则的空位，对每个位置都用一批估值函数进行打分，将估值函数的结果累加作为此位置的得分，保留得分最高的空位作为下一步落子的位置。为了方便调试，我们给每一个估值函数都分配了一定的权重，为了进一步提高算法的灵活性，我们还配置了三种不同的权重对应我们划分的对局的前、中、末三个阶段，这样，机器的决策行为可以在对局发展而调整。算法描述如下：\\[\\begin{align}记棋盘位置为P_{xy}(\\ x,y\\in \\{0,1,2,3 ...8\\})，记估值函数为F_i(i\\in {1,2,3.....n})，\\\\在棋局回合数a的权重为W_{\\omega(a)}^i(a\\in\\{x|1&lt;=x&lt;=300\\})\\\\记G_{xy}=\\{-1,0,1\\}为棋盘上x行y列的状态： \\\\G_{xy}=0表示此处没有棋子，G_{xy}=-1表示此处有对手棋子，G_{xy}=1表示此处有己方棋子。 \\\\在回合数a，对P_{i,j}\\ where\\ G_{i,j}=0，我们记Score_{i,j}=\\Sigma^{n}_{f=1}W_{\\omega(a)}^fF_f(P_{ij})为这一位置这轮决策的得分，\\\\最后我们决定在P_{mn}处下棋，s.t. Score_{mn}=max\\{Score_{ij}\\ where i,j\\in\\{0,1,2,3 ... 8\\}。\\end{align}\\]部分估值函数介绍估值函数的名字描述的是机器青睐的某种棋局形势，比如：\\[估值函数“能与同色棋子连成线”指的是，\\\\如果在P_{xy}处落子，新落的子能与四方的同色棋子当中一些连成线，则函数值F(P_{xy})&gt;0.\\]填眼这里的眼指的是四方都是己方棋子的气，这个气已被己方牢牢控制，下在红圈处对局势没有帮助，此估值函数总是输出负数。青睐有利于构造平行四边形的位置此套估值函数反映了我们的关键思路之一。刘小明和刘小宝两位同学调研了大量的比赛对局记录，结合他们过去的对围棋的理解，总结说我们应该尽力地在棋盘构造一种由四个棋子在相邻两条棋盘线上构成的图形。二刘认为这种图形能够以最少的棋子控制最多的棋盘气的数量。经反复的试验，在我们的开发框架下，刘小明构思了一套能够选中有利于构造上述图形的新颖的估值函数。第一步以下图白子所在的位置为例，检查如下四个方向上是否有两个一组的己方棋子存在，某一方向上如果有，就对这个棋子位置增加一个单位的得分。下图四个绿色方框内的两个红旗圈就分别为一组。第二步如下图四种情况，如果某一位置周围三个红圈处都存在己方棋子，则给此位置加分，与上一步骤类似，四种情况的得分累加，作为最后的估值函数输出。 优先下在棋局的四角即对如下位置，估值函数返回正数，其他返回零：\\[P_{8,8},P_{8,0},P_{0,8},P_{0,0}\\]有利于构建棋局四角的三角形如果我方已有一枚棋子在棋局一角，则对下图红圈位置输出正数，当红圈处已有我方棋子时对绿圈处位置输出正数，其他位置输出零。如下图： 能增加活棋的气的数量这一指导原则可以转化为如下几个估值函数： 描述 示意图 在此处落子，能构成至少有三个棋子的己方同色连线，如右图红圈处。 在此处落子，能让四方的气之一形成一个眼，如右图红圈处。 " }, { "title": "书单分享项目：设计分析", "url": "/posts/book-list-app-design/", "categories": "ProjectDesign", "tags": "frontend", "date": "2022-04-15 00:00:00 +0800", "snippet": " Author’s Note: basically nonsense.小小的视觉组件承担了太多的业务逻辑，这不合理，搞得我的组件不能复用，改逻辑也要到很多个地方去改。最著名的例子就是一个checkbox承担了新建书单的任务。这么一个不起眼的东西不应该包括这么多业务逻辑。在BookLIstCheckBox.svelte中，这个组件显示为一个 checkbox，依附于某一本书，对应于一个书单，...", "content": " Author’s Note: basically nonsense.小小的视觉组件承担了太多的业务逻辑，这不合理，搞得我的组件不能复用，改逻辑也要到很多个地方去改。最著名的例子就是一个checkbox承担了新建书单的任务。这么一个不起眼的东西不应该包括这么多业务逻辑。在BookLIstCheckBox.svelte中，这个组件显示为一个 checkbox，依附于某一本书，对应于一个书单，用户勾选时就把这本书添加到这个对应的书单。我认为这个组件跟操作数据库的细节距离太近。 编者按：下面应该是我之前想要厘清组件直接的相互依赖时记录的在组件之间传递的：用户用数字 id，书和书单用类的实例BookListComponent::Create import createBookList, CurrentUserId dispatch(created)::Append export let thisBookList:BookList, thisBooks:Book[], userId:number import updateBooksBookList dispatch(appended)::Rename getContext(book_list_name) dispatch(rename, {new_name, old_name})BookListComponent::AddToBookList main: export let thisBook:Book, userId:number import fetchBookListsByUserId BookListComponent::Catalog main: import $CurrentUserId, createBookList, deleteBookList, fetchBookListsByUserId, updateBooksBookList use &lt;Header/&gt;, &lt;Table/&gt; capture: Header::remove, Table::remove, Header::rename header use &lt;Rename/&gt; dispatch(remove, {book_list_title:title}) table dispatch(remove, {book_id:id}) Libaray BookBagListing getContext(Selected): read dispatch(unselect, { book:Book }) BatchOp none dispatch(all), dispatch(reverse), dispatch(clear) Entry getContext(\"toggle\"): execute , getContext(\"Selected\"): read dispatch(addToList, {book_id:number, book_list_title:string}) Filter getContext(\"Filter\"): write Listing export let entries: read main capture: unselect, all, reverse, clear import CurrentUserId, fetchAllBooks current designAddToBookListModal use &lt;PleaseProvideAuth/&gt;, &lt;ListUserBookLists/&gt;, &lt;CreateBookList/&gt;proposed designbackend services and modelsBookBook id: number path: string get title() get format()fetachAllBooks(): Book[]fetachBooksById(number[]) :Book[]BooklistBookList userId: number title: string books: number[] get id() getBooksInfo Book[] BookList(userId:number, title:string, books:number[]=[]) static fromPouchDocument({_id:string, createdBy:number, books:number[]})updateBooksBookList(userId:number, title:string, books: number[], shouldInList: boolean)createBookList(userId:number, title:string, books: number[]=[])BookList_create(title:string,books:number[]=[]) uses $CurrentUserIdfetchBookListsByUserId(userId:number):BookList[]BookList_removeBooks(bookListId:string, deadBooks:number[])BookList_addBooks(bookListId:string, newBooks:number[])fetchBOokListsContainOneBook(user:number,book:number)fetchUserBookLists(userId:number)UsercheckDisplayNameDoNotExists(displayName:string):boolean" }, { "title": "即时聊天系统的模拟设计", "url": "/posts/try-design-QQ/", "categories": "ProjectExperience", "tags": "c++, software-engineering", "date": "2021-12-21 00:00:00 +0800", "snippet": "四、总结与体会我不具备设计 complex system 的能力，在设计这个软件的过程中我很纠结，不知道该怎么设计，搞不清楚各个子系统之间要如何 interact，要遵守什么约定，使用什么样的 interface，我都搞不清。从这门课的设计要求来看，功能很多，每个功能都需要大量复杂的 infrastructure 来支撑，that is where the things get out of...", "content": "四、总结与体会我不具备设计 complex system 的能力，在设计这个软件的过程中我很纠结，不知道该怎么设计，搞不清楚各个子系统之间要如何 interact，要遵守什么约定，使用什么样的 interface，我都搞不清。从这门课的设计要求来看，功能很多，每个功能都需要大量复杂的 infrastructure 来支撑，that is where the things get out of my hands，设计这些 infrastructure 的过程，我尤其觉得力不从心。功能太多了，做不过来。未来要更加努力的学习。我花在前期设计上的时间太少了，功能设计一边做一边改。我很羡慕这个舍友刘某，他掌握了 Qt GUI 开发技术，可以很快的做出正常的 GUI 而不是用 text stream 糊弄。一、设计任务分析本小节要对设计任务进行分析。本软件的开发是一是为了应付这门课程的及格和学分，二是为了锻炼自己的 debug 能力，最后是提高自己使用 C++语言和生态的熟练度。从分发的课程设计题面来看，功能展示要求有： 开通服务情况、群成员信息等信息可以从文件系统加载。 一个服务登陆后其他服务都进入开通状态 服务之间可以根据添加好友 展示群的特色功能 群的类型的动态变换二、设计方案在本软件的输入输出方面，它和用户是通过 text stream 交互；用简单的行文本文件来保存数据到文件系统，并向其他子系统提供 key-value pair 访问的抽象。在业务逻辑部分，我把系统分成六个部分，下面逐一介绍：Meta该子系统负责处理账号的 metadata，显然，这些 metadata 一旦生成就不能修改，对用户来说是只读的，并且几乎没有必要向用户直接展示其值，且一定要有一个账号与之关联。这些 metadata 的生成很廉价，可以随意丢弃。该子系统为设计要求中记录用户的，and I quote，“号码 ID”和“T 龄”，end quote，提供支撑。目前包括两个信息： uuid，这是用户在本系统中的唯一标识符，这种标识符的值空间中元素的数量比已知宇宙中的原子数目还要多，不论其他服务开通如何，这里提供 ground truth。 creation time，这是账号的创建时间。向其他子系统提供的功能有： Get Account Meta，提供一个合理的值，包括目前系统使用的 metadata 的各字段。为了支撑系统未来的功能扩展，该系统可以做的改进有： TODO实现细节这里没有什么细节，就是一个隐藏了诸构造函数的类，用静态方法生成一个 metadata object，相关代码如下：struct AccountMeta { uuid id{}; TimeStamp creation_time{}; static AccountMeta GetAccountMeta(const string&amp; nickname); private: AccountMeta() = default;};讨论没有什么可讨论的，用随机数代替 uuid。Info该子系统负责处理 User Generated Content（UGC），也就是由用户输入进系统的内容。不用担心，虽然我们会 log 用户输入的内容，但是我们不使用受 CVE-2021-44228 以及后继 CVE-2021-45046 影响的诸程序。这种 UGC 是用户可以修改的，每个“微 × 平台”可以自己添加额外的内容，目前提供的基本信息有： display name，用户展示给其他用户的名字，可以叫做昵称。 personal tagline，个性签名，用户展示给其他用户的内容，可以用作自我介绍。向其他子系统提供的功能有： Query Info，根据账号的 uuid，查询关联的 UGC Update Info，根据账号的 uuid，更新关联的 UGC为了支撑系统未来的功能扩展，该系统可以做的改进有： TODO实现细节这里没有什么细节，就是一个数据表和一个页面用来更新账号的资料的。讨论此处最麻烦的就是在 text stream 里面处理 unicode 字符，我现在还不知道该怎么弄，至少要做两次编码的转换，一个是从用户的 terminal 到程序的内存，二个是从程序的内存再转回到 terminal。其他问题还包括微软 C++的 regex 实现中\\w并不能匹配一个中文字，要匹配一个中文字应该用[\\u4e00-\\u9fa5]才行。Account该子系统的负责处理，账号的创建和登陆，会使用到 Meta 子系统和 Store 子系统。实现细节该子系统主要包括了一个AccountService和诸面向 end user 的 UI 页面。AccountService使用三个StringTable实例，来完成如下 key-value 映射，聊以支撑用户注册和登陆，以及用户名模糊搜索的功能：flowchart LRname_hash--&gt;password_hashname_hash--&gt;uuid--&gt;nick_name用户注册时，会输入全网唯一的 display name，以及自己的密码，display name 和密码加盐散列之后，存储到数据表中。同时为该账号生成一个 uuid，并记录 uuid 到其 display name 的映射。用户登陆时，将首先给出要登陆账号的 display name，然后给出密码，AccountService加盐散列后在数据表中查询，成功匹配就告成功，AccountService便返回跟此账号关联的 uuid。一次典型的用户登陆实录如下，其中不带 prompt 的行是系统显示的，带 prompt 的是用户输入的：===Welcome! Please Login!===you may use following commands:\":quit\"Your nick name: (should match ^\\w{3,30}$)user&gt; [brave_turing]you may use following commands:\":quit\"Your password: (should match ^\\d{3,20}$)user&gt; [5416]===密码错误======Welcome! Please Login!===you may use following commands:\":quit\"Your nick name: (should match ^\\w{3,30}$)user&gt; [brave_turing]you may use following commands:\":quit\"Your password: (should match ^\\d{3,20}$)user&gt; [4544]===密码错误======Welcome! Please Login!===you may use following commands:\":quit\"Your nick name: (should match ^\\w{3,30}$)user&gt; [brave_turing]you may use following commands:\":quit\"Your password: (should match ^\\d{3,20}$)user&gt; [45448079478364]===密码错误======Welcome! Please Login!===you may use following commands:\":quit\"Your nick name: (should match ^\\w{3,30}$)user&gt; [brave_turing]you may use following commands:\":quit\"Your password: (should match ^\\d{3,20}$)user&gt; [454480794783645416]===登陆成功===我还实现了对其他用户的用户名的模糊搜索，这是方便用户查找其他账号发起聊天时使用的。这是使用正则表达式匹配实现的简单模糊搜索，典型的交互实录如下，正则表达式对于我们 SE 和 CS 专业的人才应该是非常熟练的：===用正则表达式搜索用户名，not some performant implementation===you may use following commands:\":quit\"regex: (should match ^.{3,30}$)user&gt; [(friendly)|(libq)|(b)]===单选一个======[1] brave_turing======[2] wonderful_aryabhata======[3] upbeat_northcutt======[4] boring_edison======[5] quirky_beaver======[6] flamboyant_galois======[7] festive_dubinsky======[8] infallible_roentgen======[9] boring_mirzakhani======[10] zealous_bouman======[11] friendly_chaplygin======[12] boring_antonelli======[13] hopeful_babbage======[14] friendly_goodall======[15] hardcore_black======[16] libq======end of list===you may use following commands:\":quit\"your choice: (should match ^\\d{1,4}$)user&gt; [8]===好，与infallible_roentgen开始聊天===讨论我在使用微软的 C++标准库的string的 hash 实现时，观察到了相当多的碰撞。对 3000 个随机生成的用户名逐一进行散列，它们各不相同，但是观察到只有 2500 余个不同的 hash 值，我后来尝试使用了其他的简单 hash 算法以及最简单的多项式 hash，同样观察到只有 2800 余个不同的 hash 值，我目前尚不知道是怎么回事。另外，我用 mt19937 伪随机数生成器生成的所谓 uuid 可以做得到生成 3000 次就得到 3000 个各异的随机数。Chat该子系统负责处理用户之间的消息，to do that 该子系统为其他子系统提供 Channel 抽象。Channel 用一个 uuid 来唯一标识，并负责储存 ChannelHistory，向外界提供： push，添加ChannelHistory中的信息。 pull，取得ChannelHistory中的消息。该子系统向外界提供如下服务： create channel，创建一个新的 Channel。 connect to，disconnect from，处理账号和 Channel 的关系，如果用户和 Channel 是 connected，用户就可以对这个 Channel push or pull。为了支撑系统未来的功能扩展，该系统可以做的改进有： TODO实现细节该系统目前只记录两件事，依托于下文叙述的StringTableBase模板：flowchartchannel_uuid--&gt;Channeluser's_uuid--&gt;subscribed_channels'_uuid该系统是如何完成用户聊天的功能的呢，目前的设计中有如下两种情形。例如，两个账号一对一的聊天： 要求用户登陆到甲账号，然后 ChatService 生成一个 Channel，并把 Channel 加入到甲账号的收听列表中。 用户再次输入乙账号的 uuid，ChatService 把上一步中的 Channel 加入到乙用户的收听列表中。 接下来用户可以用甲账号向该 Channel push 消息。 乙账号登陆后，检视自己账号的收听列表，逐一从里面的 Channel 中 pull 消息。再例如，一群账号的多人聊天： 按照一定的 domain logic，子系统要求 ChatService 生成一个 Channel。 多个账号请求收听上面的 Channel 的 uuid，ChatService 便把把上一步中的 Channel 加入到该账号的收听列表中。 某账号可以检视自己的收听列表，逐一从里面的 Channel 中 pull 消息。 某账号可以输入 Channel 的 uuid，并向其 push 消息。诚然，这仅仅是最基础的功能的实现，在其外围，势必要包装上诸 domain logic 才能完成面向 end user 的功能。该子系统只负责忠实传达用户之间的消息，其他内容一概不理会，应由其他子系统实现。讨论这里没有什么可讨论的，我 draw inspiration from message queue, as in the distributed system context。Store该子系统负责把软件的状态保存到文件系统中，并在软件需要时从文件系统恢复。该系统向外界提供 key-value pair container 的抽象，具体提供如下功能： get，取得跟某个 key 关联的的数据。 set，设置某个 key 关联的数据。为了支撑系统未来的功能扩展，该系统可以做的改进有： TODO实现细节file format 采用非常简单的按行分隔模式即，&lt;key&gt; &lt;value&gt;\\n为一条记录，此处需要 serialization 和 deserialization。只要使用者指定自己想要存储的数据类型的 serialization 和 deserialization 方法，就可以使用该子系统提供的功能。简单的数据类型如数字string等就按人类可读文本进行编码，稍复杂的数据类型使用 JSON 格式储存。为此我设计了StringTableBase类，用 C++的模板特性实现，设计一览如下。classDiagram\tclass StringTableBase~T~{\t-path DB_ROOT\t-path TABLE_PATH\t-StoreType store\t#Pickle pk\t#UnPickle unpk\t-load()\t-dump()\t+get(...)\t+set(...)\t}\tclass StringTable~string~\tStringTable~string~--|&gt;StringTableBase其中该模板string类型的specialization所使用的的Pickle和UnPickle是简单的 identity function。相关代码如下：template&lt;typename T=string&gt;class StringTableBase { using Pickle = std::function&lt;string(const T&amp;)&gt;; using UnPickle = std::function&lt;T(const string&amp;)&gt;; const static inline auto&amp; T_identity = [](const T&amp; s) { return s; }; using StoreType = std::unordered_map&lt;uuid, T&gt;; protected: Pickle pk; UnPickle unpk; StoreType store; ...}StringTableBase(const string&amp; DB_ROOT, const string&amp; TABLE_NAME, StringTableBase::Pickle pk = T_identity, StringTableBase::UnPickle unpk = T_identity) :DB_ROOT(DB_ROOT), pk(pk), unpk(unpk) { ...}在其他子系统中 specialized 的类实例中也有使用 JSON 格式来完成 serialization 和 deserialization 的，代码示意如图，这是模板 specializationStringTableBase&lt;Subscription&gt;中使用的 serialization 和 deserialization 方法：SubscriptionSubscription::unpickle(const string&amp; txt) { namespace j = json; auto obj = j::JSON::Load(txt); if (obj[\"sanity\"].IsNull()) {\treturn {}; } Subscription ch; ch.user_id = obj[\"channel_uuid\"].ToInt(); for (const auto&amp; id: obj[\"channels\"].ArrayRange()) {\tch.channels.insert(id.ToInt()); } return ch;}stringSubscription::pickle(const Subscription&amp; ch) { namespace j = json; auto obj = j::Object(); auto&amp; arr = obj[\"channels\"]; for (const auto&amp; id: ch.channels) {\tarr.append(j::JSON(id)); } obj[\"channel_uuid\"] = ch.user_id; obj[\"sanity\"] = true; auto json_txt = obj.dump(0, \"\"); std::replace(json_txt.begin(), json_txt.end(), '\\n', ' '); return json_txt;}讨论自己手工搭建这一所谓的 key-value pair data storage 系统并不方便，可能还不如使用成熟的 ORM 和正儿八经的数据库实现。User Interface该子系统负责处理用户的输入，并把向其他子系统提供渲染控件的功能，它使用 blocking 的 text stream 来与用户交互。提供如下功能： render，把控件展示给用户 get，返回用户交互的状态码和调用者需要的数据。为了支撑系统未来的功能扩展，该系统可以做的改进有： TODO实现细节首先为了软件调试的方便，我设计了UserInteraction类，设计一览如下。classDiagramclass UserInteraction{-ostream ots-istream ins+UserInteraction(input_path, output_path)+operator&lt;&lt;(...)+operator&gt;&gt;(...)}class ifstream{...+operator&gt;&gt;(...)}class ofstream{...+operator&lt;&lt;(...)}UserInteraction o-- ifstreamUserInteraction o-- ofstream它能从文件中导入用户的输入，并把各控件渲染的结果记录到文件中，省去我每次反复输入的烦恼。例如，要模拟用户的注册，我使用的源文件和运行时效果类似：// user input sourceeloquent_mcnulty7521856058124065wonderful_aryabhata77208342356222461amazing_mclean5306883560681846strange_leavitt469567732119057// rendered screen===开始注册新用户了===Your nick name: (should match ^\\w{3,30}$)user&gt; [eloquent_mcnulty]Your password: (should match ^\\d{3,20}$)user&gt; [7521856058124065]===注册终了======开始注册新用户了===Your nick name: (should match ^\\w{3,30}$)user&gt; [wonderful_aryabhata]Your password: (should match ^\\d{3,20}$)user&gt; [77208342356222461]===注册终了======开始注册新用户了===Your nick name: (should match ^\\w{3,30}$)user&gt; [amazing_mclean]Your password: (should match ^\\d{3,20}$)user&gt; [5306883560681846]===注册终了======开始注册新用户了===Your nick name: (should match ^\\w{3,30}$)user&gt; [strange_leavitt]Your password: (should match ^\\d{3,20}$)user&gt; [469567732119057]===注册终了===可以看到其中带有 prompt 的行是模拟用户输入的内容，其余的则是控件渲染的结果。根据系统的需要，我实现了单选控件SingleSelect和几种行输入控件LineEdit、RegexVerifiedLineEdit、RegexAndCommand，设计一览如下。classDiagramclass UserInteractionclass Component&lt;&lt;interface&gt;&gt; ComponentComponent:render()Component:get()class TextLabel{-string content-UserInteraction&amp; ui+render()}TextLabel..&gt;UserInteractionTextLabel..|&gt;Componentclass LineEdit{#Predicate predicate#UserInteraction&amp; ui#string value#string prompt+render()+get()}LineEdit..&gt;UserInteractionLineEdit..|&gt;Componentclass RegexVerifiedLineEditRegexVerifiedLineEdit--|&gt;LineEditclass RegexAndCommandRegexAndCommand--|&gt;LineEditLineEdit会读入 text stream 中一行用户的输入，将其值传给predicate判断是否接受，不接受则要求用户重新输入。RegexVerifiedLineEdit和RegexAndCommand只是一个LineEdit的 wrapper，它们用函数工厂生产各自的predictate来完成用正则表达式校验用户输入，或是解析用户的命令之功能。RegexAndCommand在使用正则表达式校验的基础上还会接受调用者指定的一些命令，然后返回调用者相应的状态码。这种控件的存在主要是让用户交互界面的设计者能够提供让用户随时退出中断当前操作的功能。典型的使用方法如下：RegexAndCommand for_pwd(\"Your password: \", R\"(^\\d{3,20}$)\", {\":quit\"});const auto&amp;[status, pwd] = for_pwd.render().get();if (status.is_good()) { // continue as password matched} else if (status.is_user_cancelled()) { // continue as user quit entering password}RegexVerifiedLineEdit使用的函数工厂示意如下：autoget_regex_validator(const std::string&amp; rgx) { return [&amp;rgx](const string&amp; txt) {\tconst auto&amp; result = std::regex_search(txt, std::regex(rgx));\treturn result; };}RegexAndCommand使用的函数工厂示意如下：//ui_components.hstruct CmdValidatorBuilder : LineEdit::Predicate { CmdValidatorBuilder(LineEdit::Predicate base,\t\t\t\t\t const std::initializer_list&lt;string&gt;&amp; acceptable_cmd); std::string received_cmd; std::set&lt;string&gt; acceptable_cmd; LineEdit::Predicate base; auto get_validator();};class RegexAndCommand : private LineEdit { public: RegexAndCommand(\t const string&amp; prompt,\t const std::string&amp; regex_expr,\t std::initializer_list&lt;string&gt; commands); CmdValidatorBuilder builder; void render() override; StatusAnd&lt;string&gt; get();}//ui_components.cppCmdValidatorBuilder::CmdValidatorBuilder(\tLineEdit::Predicate base,\tconst std::initializer_list&lt;string&gt;&amp; acceptable_cmd) :\tbase(std::move(base)), acceptable_cmd(acceptable_cmd) {}autoCmdValidatorBuilder::get_validator() { return [&amp;](const string&amp; txt) {\tif (acceptable_cmd.contains(txt)) {\t received_cmd = txt;\t return true;\t} else {\t return base(txt);\t} };}RegexAndCommand::RegexAndCommand(\tconst string&amp; prompt, const std::string&amp; regex_expr,\tstd::initializer_list&lt;string&gt; commands) :\tbuilder(get_regex_validator(regex_expr), commands),\tLineEdit(prompt + std::format(\" (should match {})\\n\", regex_expr)) { predicate = builder.get_validator();}讨论用这种方法处理 escape tokens 并不是什么理想的做法。我考虑过如下方案：把响应 predicate 结果的逻辑拔高一层，并在控件从UserInteraction提取用户输入的内容之前 hook。目前相应 predicate 结果的逻辑写在控件基类LineEdit中，其逻辑是重试直到用户输入被 predicate 接受。目前的做法：flowchart LR A[\"start\"] B[\"ui &gt;&gt; input\"] E[\"return-normal\"] rd[\"LineEdit.render()\"] Pred{\"predicates\"} subgraph while-loop rd--&gt;B Pred--&gt;|false| rd \tB--&gt;Pred; end A--&gt; while-loop Pred--&gt;|true| Eproposed 做法：flowchart LR render[\"LineEdit.render()\"]; input[\"ui &gt;&gt; input\"];\thook{hook}; prdc{\"predicates\"}; start--&gt;render subgraph while-loop \trender--&gt;input--&gt;hook--&gt;|pass through|prdc--&gt;|false| render\tend prdc--&gt;|true|return-good hook--&gt;|bail|return-abnormalMiscellaneous该部分介绍我设计的一些 make life easier 的功能。StatusAnd 模板我设计了StatusAnd模板，封装了对状态码的描述和生成的过程，避免了 magic numbers 外泄到整个系统，相关代码实例如下，状态码的 convention basically follows http status code：using Status = short;template&lt;typename T&gt;struct StatusAnd { Status status; T payload; [[nodiscard]] inline bool user_cancelled() const { return status == 499; } [[nodiscard]] inline bool is_good() const { return status == 200; } [[nodiscard]] inline bool is_bad() const { return status == 400; } static inline StatusAnd&lt;T&gt; Cancelled() { return StatusAnd&lt;T&gt;{499, {}}; } static inline StatusAnd&lt;T&gt; Good(const T&amp; p) { return StatusAnd&lt;T&gt;{200, p}; } static inline StatusAnd&lt;T&gt; Bad() { return StatusAnd&lt;T&gt;{400, {}}; }};实现细节我希望尽可能避免复制 payload object，也许使用shared_ptr是比较好的办法。讨论状态码的使用，我觉得很不方便，因为每次都要写诸如此类的 explicit branches，这很麻烦。const auto&amp; from_update = update.render().get();if (from_update.user_cancelled()) { // ...} else if (from_update.is_good()) { // ...} else { // ...}期望的效果是如下from_update.render().get() .on_good( [&amp;]() { // ... }) .on_cancelled( [&amp;]() { // ... }) .on( \"shit hits the fan\", [&amp;]() { // ... });UI 控件讨论另外本系统中大量使用了 UI 控件的概念，UI 控件是用来跟用户交互的对象，这些控件能往上述 text stream 中拉取和输出字符，并承担一定的 validation 工作。不过由于才疏学浅，我没能实现异步地实现这些 I/O 的功能。这些控件组合之后可以实现一个完成较复杂功能的页面。如果这里能异步，就可以做成 daemon-client 架构了。Escaped Commands讨论本意是想借此种命令完成页面之间的跳转，但是才疏学浅，在 UI 子系统架构设计中没有很好的支持这种功能，勉强实现了取消当前页面的操作。三、详细设计略，参见上段。" }, { "title": "如何debug。", "url": "/posts/debug-101/", "categories": "", "tags": "frontend", "date": "2021-08-17 00:00:00 +0800", "snippet": " Author’s Note: It is one of the projects required by freeCodeCamp’s Developer Certification of[Front End Development Libraries](https://www.freecodecamp.org/learn/front-end-development-libraries/...", "content": " Author’s Note: It is one of the projects required by freeCodeCamp’s Developer Certification of[Front End Development Libraries](https://www.freecodecamp.org/learn/front-end-development-libraries/#front-end-development-libraries-projects)在一个测试点卡了很久 😥，无奈到测试代码里面看了才明白是怎么回事，是真的坑 🤬。图中是测试框架模拟出发用户输入的keydown、keyup等事件，把e这个Array中的 ascii code 当作 keycode来构造相应的事件。但是从图上看，这一串列表里面装的全都是大写字母的 ascii code，但是按照设计，真实用户不会用shift键来修饰，输入的都是小写的 keyboard event，但这边构建测试 mock 的时候用的都是大写的字母。这就导致了我如下断言总是返回假。e.key === this.props.keyTrigger.toLowerCase();讲道理的话 🤔，我左边假定用户输入小写字母肯定没错，但是如果多一点所谓防御性编程 defensive programming的想法的话，应该保证两边都是小写，这样也提高了所谓的鲁棒性 robustness。btw，这两个词翻译得是真的 💩。e.key.toLowerCase() === this.props.keyTrigger.toLowerCase();不过这次 debug 过程还反映出我 debug水平不够的问题，我不懂得按照逻辑链条一步一步的分析，从头到尾都是在播放声音的函数里边纠缠，不懂得往调用链上游排查，下游就是浏览器接口了，不是我写的代码，不需要深入。途中还错误地怀疑是否异步的调用audio.play()没有在测试环境下被立刻处理，而导致紧随 fire keyboard event 的检查音频播放状态的代码检查出 audio 尚未开始播放。具体的看截屏再复现了。我在这个用例卡了一个小时，期间反复在做两件事，一个是比对我的代码跟模版代码，二个是怀疑上面说的异步的问题。这还反映出我不会灵活应用排错技术，为什么不下断点或者console.log呢？真的醉了，codepen 编辑器这一陌生的开发环境中，同样可以使用这些基本的排错技术。在DevTool 里可以看得到经 Babel 编译得到的 vanilla JavaScript，下断点是轻而易举的，console.log更不用说。" }, { "title": "数据查询习题：用 pandas 解决", "url": "/posts/SQL-trickery/", "categories": "", "tags": "pandas, python, database", "date": "2021-08-17 00:00:00 +0800", "snippet": "题目描述假定你是李明，你拿到一份记录有 123 家企业在 2016~2020 四年期间的销售记录。记录的形式如下：对每一笔交易，记录企业 id，买家 id，交易发生年份，这样的记录共有 16 万余条，以 csv 格式存储在文件系统中。如下图：李明的任务是对每一家企业E1, E2, ..., E123统计与它们合作了 1,2,3,4 年的合作伙伴的数量。结果应类似下图： ...", "content": "题目描述假定你是李明，你拿到一份记录有 123 家企业在 2016~2020 四年期间的销售记录。记录的形式如下：对每一笔交易，记录企业 id，买家 id，交易发生年份，这样的记录共有 16 万余条，以 csv 格式存储在文件系统中。如下图：李明的任务是对每一家企业E1, E2, ..., E123统计与它们合作了 1,2,3,4 年的合作伙伴的数量。结果应类似下图： 4 3 2 1 id E47 80 107 160 420 E1 71 52 52 185 E9 45 24 29 26 E2 43 123 275 1170 E8 31 170 432 2098 ... ... ... ... ... E120 0 0 0 26 E104 0 0 0 10 E115 0 0 0 4 E96 0 0 0 3 E101 0 0 0 2 123 rows × 4 columns表格含义解读：E47号企业合作了 4 年的合作伙伴有 80 家，而E101号企业只有两个刚刚合作一年的伙伴，E8则有多达 2000余家合作了一年的合作伙伴。不太好的思路一开始我是想先把每个企业每年的合作伙伴都列举出来：ff.groupby(by=['id', 'yr'])['sold'].unique()id yrE1 2017 [B03711, B00844, B03700, B10763, B00713, B0351... 2018 [B09944, B03455, B07545, B07664, B07993, B0129... 2019 [B00385, B00983, B04335, B04337, B03455, B0754... 2020 [B00812, B00813, B01025, B03199, B03455, B0754...E10 2016 [B10116, B07899, B00892, B00002, B07900, B0302... ...E98 2018 [B03020, B03022, B03805, B03154, B03869, B03518] 2019 [B04162, B03020, B09633, B10459, B02361, B0277... 2020 [B03022]E99 2018 [B00892, B00637] 2019 [B00892, B03170]Name: sold, Length: 435, dtype: object然后用分治法，先考虑一个企业的记录：ff.groupby(by=['id', 'yr'])['sold'].unique()\\.loc['E10'].to_frame()['sold']yr2016 [B10116, B07899, B00892, B00002, B07900, B0302...2017 [B00002, B10337, B01616, B00641, B07899, B0089...2018 [B07693, B01930, B10337, B00697, B00212, B0067...2019 [B00678, B01930, B03643, B10337, B00685, B0069...Name: sold, dtype: object然后想着把每一行里面的列表拆开，准备等会在用value_counts计数每一个的出现次数。ff.groupby(by=['id', 'yr'])['sold'].unique()\\.loc['E10'].to_frame()['sold']\\.apply(pd.Series).unstack().dropna() yr0 2016 B10116 2017 B00002 2018 B07693 2019 B006781 2016 B07899 2017 B10337 2018 B01930 2019 B01930...15 2017 B03643dtype: object这样合作伙伴代号都拆开了，每一行有一个合作伙伴代号。然后用两次value_counts计算出现了 1,2,3,4 次的代号分别有多少个。ff.groupby(by=['id', 'yr'])['sold'].unique()\\.loc['E10'].to_frame()['sold']\\.apply(pd.Series).unstack().dropna()\\.value_counts().value_counts()1 143 64 42 3dtype: int64这样就完成了一个企业的统计，下面把同样的过程应用到每一个 idff.groupby(by=['id', 'yr'])['sold'].unique().to_frame()\\.groupby('id').apply( lambda tt:tt['sold']\\ .apply(pd.Series).unstack().T\\ .value_counts().value_counts()).to_frame().unstack()\\.fillna(0).astype(int).droplevel(0, axis='columns')基本上跟单个的时候一致，只有两个区别，apply 的算子接收到的参数类型就是pd.DataFrame，而上面loc得到的是pd.Series，这里就不需要to_drame操作了。再有一个是需要用转置换成pd.Series后面才能使用value_counts。这种方法是比较慢的，而且也比较不合理，不是正确的 pandas 使用方法。因为使用了比较多的apply跟反复两次to_frame，应该多使用pandas 提供的功能。计时结果如，需要 2 秒余：%%timeit -n 7 -r 10ff.groupby(by=['id', 'yr'])['sold'].unique().to_frame()\\.groupby('id').apply( lambda tt:tt['sold']\\ .apply(pd.Series).unstack().T\\ .value_counts().value_counts()).to_frame().unstack().fillna(0).astype(int)\\.droplevel(0, axis='columns')\\.sort_values(by=[4,3,2,1], ascending=False).reindex(columns=[4,3,2,1])7 loops, best of 10: 2.19 s per loop比较好的思路后来我以年份来考虑%%timeit -n 7 -r 10ff.groupby(by=['id', 'sold', 'yr']).size().unstack().fillna(0).astype(bool)\\.apply(lambda row:int(sum(row)), axis=1).astype(int)\\.unstack().fillna(0).T.astype(int)\\.apply(lambda row: row.value_counts()).fillna(0).drop(0, axis='index')\\.astype(int).T.sort_values(by=[4,3,2,1], ascending=False)\\.reindex(columns=[4,3,2,1])7 loops, best of 10: 474 ms per loop用 SQL 来写SELECT\tid,\tycnt,\tcount( 1 ) as pcntFROM\t(\tSELECT\t\tid,\t\tsold_to,\t\tsum( yc ) AS ycnt\tFROM\t\t(\t\tSELECT\t\t\tid,\t\t\tsold_to,\t\t\tcount( 1 ) AS yc\t\tFROM\t\t\t( SELECT DISTINCT id, sold_to, year FROM quiz )\t\tGROUP BY\t\t\tid,\t\t\tsold_to,\t\t\tyear\t\t)\tGROUP BY\t\tid,\t\tsold_to\t)GROUP BY\tid,\tycnt效果示例： id ycnt pcnt E1 1 185 E1 2 52 E1 3 52 E1 4 71 " }, { "title": "神机妙算算法竞赛", "url": "/posts/shenjimiaosuan-contest/", "categories": "ProjectExperience", "tags": "c++, algorithm", "date": "2021-07-31 00:00:00 +0800", "snippet": " Author’s Note: I got my first pull request merged into Open3D’s codebase, albeit a minor fix.本次比赛共有三个题目，使用 C++编程语言，要求只能提交一个源文件。只能提交一个源文件的这个要求，后来发现实现起来不是很轻松。第二题 三角网补色本题给定一个三维空间中的三角网，约有四分之一的三角形没有被涂...", "content": " Author’s Note: I got my first pull request merged into Open3D’s codebase, albeit a minor fix.本次比赛共有三个题目，使用 C++编程语言，要求只能提交一个源文件。只能提交一个源文件的这个要求，后来发现实现起来不是很轻松。第二题 三角网补色本题给定一个三维空间中的三角网，约有四分之一的三角形没有被涂上颜色，要求把颜色补齐，空缺颜色按照相邻有色三角形的按通道平均值填入。按照题目要求，显然如果一个空缺的色块的三个邻居全都是有颜色的色块，那么它的颜色是唯一确定的。主要讨论多个空缺色块连成一片时如何处理。我的思路同样非常简单，即把相连空缺色块视为同一块，找出他们的所有相邻色块计算平均值填入。这种处理成片空缺色块的方法是比较草率的，如下图，补出来的色块比较突兀，明显看得出瑕疵。还有另一个问题是，下图用作测试用例的球的三角网的三通道RGB 颜色$ ch_i $是用正态分布指派的：$ch_i\\sim N(140,30)\\ i\\in{1,2,3}$，不能保证已知颜色的点满足题目要求某三角形的颜色是其相邻三个三角形颜色的平均值。我生成随机颜色的方法也使得所补进去的颜色大多是相近的浅灰淡紫色。比较好的处理方法是同时考虑连片平均色和相邻最近的颜色。更复杂的，我们可以考虑 n 阶邻居的颜色，并使得邻居之间的颜色变化一致，随后抽象成一个回归问题。把三角网抽象成图，每一个三角形对应一个顶点，有公共边的三角形之间有一条边。为了简便计算，假设每个顶点的度都是3，从给的样例来看这是成立的。某顶点的 n 阶邻居可以定义为，到某顶点的最短路为 n 的顶点集合。某顶点$v$ 的 1阶邻居有$ng_1,ng_2,ng_3$ 三个，显然我们可以把顶点$v$的$k,\\ where\\ k\\in{2,3,4…n}$ 阶邻居给划分为 3 类，记为$N_i$，且有：$ng_i\\in N_i,\\ where\\ i\\in {1,2,3}$。那么对每个顶点，都可以得到 3 个序列：$CR_{j}^i, where\\ i\\in {1,2,3,…,n},\\ j\\in{1,2,3}$，其中$CR_{j}^i$ 是$N_j$ 中$i$阶邻居的颜色值。然后可以分别考虑三个$CR_j$方向上的颜色序列，可以使用负责的数值拟合、回归的方法得到每一支上的空缺颜色预测值，最后按照一定的方法综合考虑形成最终答案，最简单的可以是按通道取算数平均。实现总结这道题的具体实现比较差，可以改进的地方如：在读入点云数据后，接下来的构建的边、三角面等几何实体全部使用点的索引而不是点的坐标，这样可以避免浮点数之间的相等比较，也能够节省内存空间；转化三角网成图的过程中使用哈希表std::unordered_map而不是红黑树std::map，毕竟边之间的偏序关系是没有几何语义的；寻找连通空缺块时的具体算法还可以再优化，这里不赘述了。寻找三角网中的连通空缺块从每一个空缺颜色的三角块出发，用 BFS 寻找空缺颜色的连通块。把找到的连通块的三角面的序号列表加入哈希集合以去重。这不是最高效的算法，但足够好了。class VectorHashCalc { public: size_t operator()(const std::vector&lt;unsigned int&gt;&amp; v) const { std::hash&lt;unsigned int&gt; hasher; size_t seed = 0; for (auto i : v) { seed ^= hasher(i); } return seed; }};class VectorEquality { public: bool operator()(const std::vector&lt;unsigned int&gt;&amp; a, const std::vector&lt;unsigned int&gt;&amp; b) const { return std::is_permutation(a.cbegin(), a.cend(), b.cbegin()); }};std::vector&lt;std::vector&lt;unsigned int&gt;&gt; all_empty_group(const TriMesh&amp; mesh, const AdjList&amp; adj_tri) { const Color&amp; EMPTY_COLOR = Color(255, 255, 0); std::unordered_set&lt;std::vector&lt;unsigned int&gt;, VectorHashCalc, VectorEquality&gt; empty_group_set; for (int i = 0; i &lt; mesh.size(); ++i) { bool is_empty = mesh[i].rgb == EMPTY_COLOR; if (is_empty) { const auto&amp; candi = empty_group(mesh, adj_tri, i); if (not candi.empty()) { empty_group_set.insert(candi); } } } std::vector&lt;std::vector&lt;unsigned int&gt;&gt; ans; std::move(empty_group_set.begin(), empty_group_set.end(), std::back_inserter(ans)); return ans;}三角网可视化小工具先把 ply 格式的三维模型转换成比赛所用的格式，并随机指派颜色，随后进行比赛官方三角网格式转换到 plotly.js 格式，最后在浏览器中用plotly.js作图，可以直观看到图形和颜色。球的三角网的颜色是随机生成的，已填颜色的色块用正态分布指派，空缺块的颜色使用上述算法填充，黄色表示空缺的三角块。大球的颜色给得不是很好，官方样例给的颜色比较相近的浅灰色，如果使用\\(\\mu\\)更小一些的正态分布，会好一些。第三题 重建点云的表面本题给定一批三维空间的点，要求重建其表面，保证没有在立体内部的点。这个题看起来是最简单的一个题，因为这一任务是被广泛的研究过的，有许许多多现成的代码可以使用。不过当时我没有太多思考就决定要走重用关键代码，自己实现其他依赖的这条路。回想起来呢，我可以先试一下用自动化工具整合所有依赖成为单一源码，看看是否会超出比赛对源码文件大小的限制。并且我也没有尝试自己按照论文来实现，而是浪费了大约一周，20余小时来努力把别人写好的代码搬运到自己的环境中使用。我当初选定的是BallPivoting算法，这个算法直观简单，大概也可以应付比赛用例的需求。这个算法的依赖其实也特别多，需要先给点估算法向量、三维convexhull、三维德劳内三角化。这些东西背后还需要三维空间搜索树，向量的特征值等基础性功能。当时做得挺痛苦的，只想快点结束，也根本没有心思慢慢读论文，琢磨之后自己实现一个简单的。我还是太缺少规划了，极大的低估了这条路的艰辛，我不熟练在C++环境下整合第三方代码到自己的项目中来。CMake 只会一些基本操作，不会自定义。我其实应该自己努力实现一个早期的表面重建算法，如 power crust，这样收获更多。本题的实现几乎全部是用的别人的实现，我自己做了一些 adapter 来提供 API 罢了，没有什么技术含量。核心的 BallPivoting 算法是用的open3D 的实现，其中又需要依赖计算 convex hull，三维三角化。这两个计算的代码是费了一点功夫在网络上找的开源代码，都是论文作者释出的源码。至于最终结果的正确性，我心里也没底，测试估算法向量代码时，在open3D 的测试用例下，总是有一两个是错误的。第一题，三头遍历本题给定一个无向图简单图，我要指挥三个以光速飞行的飞机，它们从三个不同节点出发，负责遍历图的每一个节点，最后在同一个节点结束。光速飞行也就是边上旅行时间不计，所有节点都是需要一个单位的时间，每个节点只需要搜索一次，之后再经过时不耗费时间。题目就是要求安排这三架飞机的飞行轨迹。然后给出几个评价指标： 最长飞行轨迹和最短飞行轨迹当中包含的节点数量差 每架飞机负责搜索的节点的个数分配平均程度 ……我的整体思路是这样的，各个飞机把其他飞机视为对手，每一步决策的时候都希望远离其他两个飞机，这样子三个搜索区域就大致可以均匀的覆盖所有的节点。具体算法也比较简单，直观的说就是，每个飞机每次先考虑自己所在节点的相邻节点，如果相邻节点都被搜索过了那就考虑全局未搜索节点。考虑节点的方法就是对每个可行的节点计算其余两个飞机分别和我的路程差，也就是二元组：\\[(distance(a'_1, node)-distance(a, node),\\ distance(a'_2, node)-distance(a, node))\\ where\\ node \\in candidates\\]其中$a’_1, a’_2$ 是另外两个飞机所在的节点。\\(candidates\\)是邻居节点集并上全局未搜索节点集。此后按照一定的步骤排序选出最好的一个节点。方法是，先看每个二元组里面最小的数，这些数不妨成为局部最小值，然后看这些局部最小值里面最大的一批，如果只有一个那就选择这个，这个节点对另外两个飞机来说都是比较远的。如果有多个二元组的局部最小值是一样的，那就再按照二元组的和来选，选取加和最大的。代码如下：auto local_min = [](const EvalOfNode n) { return *std::min_element(n.second.cbegin(), n.second.cend());};auto resulted_in_by = [](const EvalOfNode n) { return n.first;};std::sort(values.begin(), values.end(), [local_min](const EvalOfNode&amp; a, const EvalOfNode&amp; b) { return local_min(a) &lt; local_min(b); });auto utilmaxmin = std::count_if(values.cbegin(), values.cend(), [&amp;values, &amp;local_min](const EvalOfNode&amp; n) { return local_min(n) == local_min(values.back()); });if (utilmaxmin == 1) { return resulted_in_by(values.back());} else { auto diff_sum = [](const EvalOfNode n) { return std::accumulate(n.second.cbegin(), n.second.cend(), 0); }; std::sort(values.begin(), values.end(), [&amp;diff_sum](const EvalOfNode&amp; a, const EvalOfNode&amp; b) { return diff_sum(a) &lt; diff_sum(b); }); return resulted_in_by(values.back());}代码中EvalOfNode.second就是上面说的二元组。上面的部分就解决了每个飞机如何选择自己的下一个搜索目标的问题。剩的的部分还有最短路径规划和整体模拟循环。题目要求没有完成所有搜索任务之前不能经过集合点，我必须给普通的 BFS最短路算法加上黑名单机制，必要时飞机要绕路避开集合点。整体模拟循环规定每一步模拟，每个飞机都要搜索一个节点，所有节点都搜索完毕的时候立刻结束模拟，每一步模拟都会根据飞机选择的节点更新地图知识库，都是常规操作。每一步规定每个飞机都必须搜索一个节点，那么可以保证在搜索个数一定是平衡的。bool sim::make_simulation_step(world::Knowledge&amp; KM, const world::Map&amp; MAP) { for (const auto&amp; agent : {AgentIndex::zero, AgentIndex::one, AgentIndex::two}) { const NodeIndexList sites = MAP.all_nodes(); bool consider_done = std::all_of(sites.cbegin(), sites.cend(), [&amp;KM](NodeIndex site) { return not KM.can_search(site); }); if (consider_done) { return false; } NodeIndex go_to = sim::where_to_go(agent, KM, MAP); NodeIndexList path = MAP.path(KM.where_is(agent), go_to, MAP.size() - 1); KM.log_path_of(agent, path); KM.log_search(agent, path.back()); } return true;}模拟结束之后，各飞机在地图上的位置没有定数，预先不能确定，总之让所有飞机回到集合点就可以了。从具体实现来看，我把系统分成三个部分：world::Knowledge此系统负责记录每个飞机的飞行轨迹和它们在任一时刻的位置。为了实现全地图未搜索完成时避开最终集合点的功能还实现了记录黑名单节点的功能。最后还要负责按照官方要求的格式或是便于debug 的格式打印输出飞机飞行历史。例如，为了方便调试，飞机经过而不搜索的节点序号，后边跟着一个波浪线。show history:0: 0 1~ 10 8 7 11~1: 1 9 5 4~ 6 11~2: 2 3 4 11~official format:0 1 10 8 7 111 9 5 4 6 112 3 4 11world::Map此系统实现了无向图，并提供基于 BFS 的最短路径算法，以及调整过的带有黑名单特性的版本。NodeIndexList world::Map::path(NodeIndex start, NodeIndex end, NodeIndex blockage) const { if (blockage == start or blockage == end) { return {}; } if (start == end) { return {}; } if (world::Map::are_neighbours(start, end)) { return {start, end}; } NodeIndexList parent(m_adj.size(), std::numeric_limits&lt;NodeIndex&gt;::max()); std::vector&lt;bool&gt; status(m_adj.size(), false); std::queue&lt;NodeIndex&gt; q; q.push(start); status[start] = true; while (!q.empty()) { auto me = q.front(); q.pop(); NodeIndexList within_one_step = world::Map::neighbours_of(me); std::remove_if(within_one_step.begin(), within_one_step.end(), [&amp;blockage](NodeIndex site) { return site == blockage; }); for (const auto&amp; nghb : within_one_step) { if (!status[nghb]) { q.push(nghb); status[nghb] = true; parent[nghb] = me; if (nghb == end) { return std::move(construct_path(start, end, parent)); } } } } throw std::invalid_argument(\"graph is not connected!\");}world::simulation本系统实现上述选择下一个搜索目标的逻辑和整个任务的主循环。NodeIndex sim::where_to_go(AgentIndex agent, const world::Knowledge&amp; KM, const world::Map&amp; MAP) { const auto&amp; nghbs = MAP.neighbours_of(KM.where_is(agent)); NodeIndexList candi; std::copy_if(nghbs.cbegin(), nghbs.cend(), std::back_inserter(candi), [&amp;KM](const NodeIndex node) { return KM.can_search(node); }); if (candi.empty()) { for (NodeIndex i = 0; i &lt; MAP.size(); ++i) { if (KM.can_search(i)) { candi.emplace_back(i); } } } if (candi.empty()) { throw std::logic_error(\"all sites in MAP have been searched\"); } EvalOfNode node_value; std::vector&lt;EvalOfNode&gt; values; auto dist = [&amp;KM, &amp;MAP](AgentIndex ag, NodeIndex node) { return static_cast&lt;int&gt;(MAP.distance_of(KM.where_is(ag), node)); }; for (const NodeIndex&amp; node : candi) { std::vector&lt;int&gt; dist_diff; for (auto ag : {AgentIndex::zero, AgentIndex::one, AgentIndex::two}) { if (ag != agent) { dist_diff.emplace_back(dist(ag, node) - dist(agent, node)); } } values.emplace_back(EvalOfNode{ node, {dist_diff.front(), dist_diff.back()} }); } auto local_min = [](const EvalOfNode n) { return *std::min_element(n.second.cbegin(), n.second.cend()); }; auto resulted_in_by = [](const EvalOfNode n) { return n.first; }; std::sort(values.begin(), values.end(), [local_min](const EvalOfNode&amp; a, const EvalOfNode&amp; b) { return local_min(a) &lt; local_min(b); }); auto utilmaxmin = std::count_if(values.cbegin(), values.cend(), [&amp;values, &amp;local_min](const EvalOfNode&amp; n) { return local_min(n) == local_min(values.back()); }); if (utilmaxmin == 1) { return resulted_in_by(values.back()); } else { auto diff_sum = [](const EvalOfNode n) { return std::accumulate(n.second.cbegin(), n.second.cend(), 0); }; std::sort(values.begin(), values.end(), [&amp;diff_sum](const EvalOfNode&amp; a, const EvalOfNode&amp; b) { return diff_sum(a) &lt; diff_sum(b); }); return resulted_in_by(values.back()); }}本实现使用 C++ STL 来实现候选节点的筛选、评估排序，用 lambda表达式精简纸面代码，便于阅读。其中若地图中找不到合适的搜索目标候选，会抛出异常，本函数不负责终止模拟，只负责确定某一架飞机下一个搜索节点。bool sim::make_simulation_step(world::Knowledge&amp; KM, const world::Map&amp; MAP) { KM.add_blacklist(MAP.size() - 1); for (const auto&amp; agent : {AgentIndex::zero, AgentIndex::one, AgentIndex::two}) { const NodeIndexList sites = MAP.all_nodes(); bool consider_done = std::all_of(sites.cbegin(), sites.cend(), [&amp;KM](NodeIndex site) { return not KM.can_search(site); }); if (consider_done) { return false; } NodeIndex go_to = sim::where_to_go(agent, KM, MAP); NodeIndexList path = MAP.path(KM.where_is(agent), go_to, MAP.size() - 1); KM.log_path_of(agent, path); KM.log_search(agent, path.back()); } return true;}本函数实现一个简单的模拟循环，每个循环中为每个飞机确定下一个搜索目标，然后更新world::Knowledge中飞机的位置、飞行轨迹等。当所有节点都被搜索过后返回非旗标给调用者。它的典型调用者如下：while (sim::make_simulation_step(KM, MAP)) { ;}循环体内可以写入用户感兴趣的调用，实际编码时常写入除错断言。实现总结本实现方便测试，模拟循环的可观察性非常好。给定两个确定的 KM，MAP物件就可以测试模拟循环和搜索目标选择算法的正确性。各系统之间充分解耦，共同依赖于稳定的领域假定，如，节点序号是自然数且从零开始编号，三架飞机从序号最小的三个节点0、1、2 号出发，搜索完毕后集结于序号最大的节点等。这些假定硬编码在实现中，如：Knowledge() : m_loc{0, 1, 2}, m_searched_by({ {0, AgentIndex::zero}, {1, AgentIndex::one}, {2, AgentIndex::two} }) {};" }, { "title": "计算机科学各研究领域论文选读", "url": "/posts/career-path-exploration/", "categories": "Memo", "tags": "career-path, read-papers, thoughts", "date": "2021-07-27 00:00:00 +0800", "snippet": "CCF groups computer science research journals and conferences into the following fields. 计算机体系结构/并行与分布计算/存储系统 计算机网络 网络与信息安全 软件工程/系统软件/程序设计语言 数据库/数据挖掘/内容检索 计算机科学理论 计算机图形学与多媒体 人工智能 人机交互与普适计算...", "content": "CCF groups computer science research journals and conferences into the following fields. 计算机体系结构/并行与分布计算/存储系统 计算机网络 网络与信息安全 软件工程/系统软件/程序设计语言 数据库/数据挖掘/内容检索 计算机科学理论 计算机图形学与多媒体 人工智能 人机交互与普适计算 交叉/综合/新兴papers#3 One way to select many This paper is accepted by ECOOP which is rated as class B by CCCF.It is to address this problem: software industry has not managed to establish precisestandard semantics for selecting multiple elements from collections and, consequently, to produce easily reused implementations of selection featuresand it propose: the abstractions that capture the essence of multi-selection features and enable their precise and concise specification, and their generic implementationIt points out current deficient: The precise meanings of these actions, however, are not established, as evidenced by the below review of sample applications.This work is quite good, because the author gets to write a lot of javascript code that solves a concrete problem in the industry. More importantly, the author proposed an general abstraction for such user interaction scenario. He decomposes seemingly complex use-case into reuseable pieces and expresses them with formal language.I am always facinated with abstraction in software engineering.#4 A Survey of State Management in Big Data Processing Systems This paper is accepted by VLDB J. which is rated as class A journal by CCCF.This paper discuss everything you can do with such “state” in database system, such as managing state, using state. It addresses all aspects in the following plot:However I find an interesting statement in that paper which is going to be our sample paper from #1#1 Complexity Analysis of Checkpoint Scheduling with Variable Costsit’s published on IEEE Trancsactions on Computers which is a class A journal per CCCF.It give abstract and general definition to such real world problem: we propose a performance model that expresses formally the checkpoint scheduling problemWhat I am interestered in: In particular, we prove that the checkpoint scheduling problem is NP-hard even in the simple case of uniform failure distributionsimple introduction to checkpoint scheduling problem: One of the main problems for this technique is to determine theright series of intervals for checkpointing. Indeed, too many checkpoints would increase the time overhead while too fewcheckpoints would lead to a large loss of computation time in caseof failures. The time when to perform the checkpoints dependsmainly on two parameters, namely, the volume of data to checkpoint (due to communication times) and the failure arrival time distribution.The paper develop a formal (means using a lot of fancy mathmatic notations) model for computional execution and failure. Basically the models provides an abstract on failures and computations. Base on these models, author fomulates a description for the scheduling problem in the abstraction level of vectors and integers, integrals, uniform distributions. And then author proposed a dynamic programming algorithm based on some simplifing assumptions.#8 人机交互与普适计算This category is seemingly unrelated with computer science as in TOCHI vol. 27. An Activity Centered Approach to Nonvisual Computer InteractionThis paper studies UI specific to blind and low-vision computer users. Damn, I don’t give a fuck to those blind people, who cares? Countdown Timer Speed: A Trade-off between Delay Duration Perception and RecallTweak the progree bar to make it seems moving faster in order to increase satisfactory or decrease annoyance (in case of advertisements). The Unexpected Downside of Paying or Sending Messages to People to Make Them Walk: Comparing Tangible Rewards and Motivational Messages to Improve Physical ActivityBy the article title, there is nothing to do with computers. Authors conducted 10 months of experiments on 208 participants, which is truly remarkable undertaking. Interestingly, this paper concludes that such persuasive techniques actually decrease the intrinsic motivation of the participants. I would say that’s counterintutive, are all those “exercise” apps doing it in vain? Engagement by Design: An Empirical Study of the “Reactions” Feature on Facebook Business PagesFacebook reactions, crap, is this even “科研“？ Collection of Metaphors for Human-Robot Interaction Abstract: The word “robot” frequently conjures unrealistic expectations of utilitarian perfection: tireless, efficient, and flawless agents. However, real-world robots are far from perfect—they fail and make mistakes. Thus, roboticists should consider altering their current assumptions and cultivating new perspectives that account for a more complete range of robot roles, behaviors, and interactions. To encourage this, we explore the use of metaphors for generating novel ideas and reframing existing problems, eliciting new perspectives of human-robot interaction. Our work makes two contributions. We (1) surface current assumptions that accompany the term “robots,” and (2) present a collection of alternative perspectives of interaction with robots through metaphors. By identifying assumptions, we provide a comprehensible list of aspects to reconsider regarding robots’ physicality, roles, and behaviors. Through metaphors, we propose new ways of examining how we can use, relate to, and co-exist with the robots that will share our future.我也是醉了，这搞的啥啊。#5 Scalable Termination Detection for Distributed Actor SystemsThis paper solves real-world problem in distributed systems. That is Garbage collection of actor instances in a distributed actor system. Plenty of mathmatic notations and logical proof are used in the paper.it’s Very Very abstract. There is this conference called concurency, but I am not familiar with most of the nonus appear in proceeding titles. Monte Carlo Tree Search Guided by Symbolic Advice for MDPs Abstract: In this paper, we consider the online computation of a strategy that aims at optimizing the expected average reward in a Markov decision process. The strategy is computed with a receding horizon and using Monte Carlo tree search (MCTS). We augment the MCTS algorithm with the notion of symbolic advice, and show that its classical theoretical guarantees are maintained. Symbolic advice are used to bias the selection and simulation strategies of MCTS. We describe how to use QBF and SAT solvers to implement symbolic advice in an efficient way. We illustrate our new algorithm using the popular game Pac-Man and show that the performances of our algorithm exceed those of plain MCTS as well as the performances of human players.I don’t how this is related to concurrency.There is this journal called Algorithmica. This is actually pretty cool, most paper focus on tangible and concrete algorithm just like those we are taught in universities. Sort Real Numbers in \\(O(n\\sqrt{logn})\\) Time and Linear SpaceThis paper converts real numbers to integers then use non comparison based algorithm to sort them thus break the illusion that real numbers have to be sorted by comparison sorting. The author give no implementations." }, { "title": "设计一个键值对型数据库。design of a key-value pair database in python", "url": "/posts/design-of-a-key-value-pair-database-in-python/", "categories": "", "tags": "data-structure, python, database", "date": "2021-06-10 00:00:00 +0800", "snippet": "schemabinary representation in file systemA database is represented by a directory in the file system. Every time we access a certain database, we create a new file. One crucial decision of our dat...", "content": "schemabinary representation in file systemA database is represented by a directory in the file system. Every time we access a certain database, we create a new file. One crucial decision of our database is that it append to existing file at all time. In order to update the value associated with certain key, we append a record containing the updated value with an older time stamp. To delete a key, we change it to a pre-defined key called TOMB_STONE.Each file in the file system consists of a number of consecutive binary records following the schema: timestamp | key size | value size | key | value. The first three sections are “metadata”, the last two sections are “payload”. Note that metadata in our schema has a fixed size. Timestamp is a 8B floating point denotes the number of seconds since Unix epoch. Key size and value size are long long integers, typically 8B, which supports payload size of over 1 million TB. Key and value objects must be native python strings. They get serialized into ascii-encoded, variable length python native bytes.in-memory representationa python native dictionary that maps key object to a wrapper that wraps necessary metadata together with the actual value. That requires object must be hash-able. And extra metadata is required, the schema for the wrapper object looks like file id | time stamp | binary size of value | offset in file | actual value object.database indexa python native dictionary maps key object to seek position of the file. this dictionary is restored during the initialization phase.working overviewinitialization phaseWe iterate over every files in the given directory.For every record we encountered, we update the wrapper object in our in-memory model if this item 1) does not exist in our model or 2) has a newer time-stamp or 3) has TOMB_STONE as its key.key insertion, update and deletionWhen user puts a key-value pair into database, we dump it immediately to file system via a IO proxy. This IO proxy provides time stamp, offset, binary size of value metadata that needed by in-memory model.When user query a key, if the key exists in memory model, we read the actual payload from file system according to previously recorded metadata.When user deletes a key, we delete it from memory model, and overwrite that key on the file system with TOMB_STONE.limitationsOur append-only files grows rapidly if user repeatedly updates or deletes then inserts the same key." } ]
