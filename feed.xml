<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://li6in9muyou.github.io/</id><title>Li6q 笔记</title><subtitle>I write about my dev experiences.</subtitle> <updated>2025-08-25T11:19:52+08:00</updated> <author> <name>Li 6in9Muyou</name> <uri>https://li6in9muyou.github.io/</uri> </author><link rel="self" type="application/atom+xml" href="https://li6in9muyou.github.io/feed.xml"/><link rel="alternate" type="text/html" hreflang="zh-CN" href="https://li6in9muyou.github.io/"/> <generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator> <rights> © 2025 Li 6in9Muyou </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>rg 基础。rg 101</title><link href="https://li6in9muyou.github.io/posts/rg-101/" rel="alternate" type="text/html" title="rg 基础。rg 101" /><published>2024-06-26T00:00:00+08:00</published> <updated>2024-06-26T19:35:45+08:00</updated> <id>https://li6in9muyou.github.io/posts/rg-101/</id> <content src="https://li6in9muyou.github.io/posts/rg-101/" /> <author> <name>Li 6in9Muyou</name> </author> <category term="HowTo" /> <summary> THIS IS A WORK IN PROGRESS search PATTERN in files but exclude files whose path matches EXCLUDE_PATH_PATTERN ! means exclude, -g option expects GLOB not regex. $ rg hello -g !*node_modules* </summary> </entry> <entry><title>git 基础。git 101</title><link href="https://li6in9muyou.github.io/posts/git-101/" rel="alternate" type="text/html" title="git 基础。git 101" /><published>2024-05-10T00:00:00+08:00</published> <updated>2025-07-13T21:28:59+08:00</updated> <id>https://li6in9muyou.github.io/posts/git-101/</id> <content src="https://li6in9muyou.github.io/posts/git-101/" /> <author> <name>Li 6in9Muyou</name> </author> <category term="HowTo" /> <summary> THIS IS A WORK IN PROGRESS fetch a huge code base partially reference &amp;gt; git clone ssh://git@example.com/.git --depth 1 --branch release use the following command to further fetch all history but leave out all the files which is relatively fast &amp;gt; git fetch --filter blob:none use the following command to do git pull because git pull fails in repos init’ed with commands above. &amp;gt; g... </summary> </entry> <entry><title>大略了解并发模型。seven concurrency models in seven weeks</title><link href="https://li6in9muyou.github.io/posts/concurrency-models/" rel="alternate" type="text/html" title="大略了解并发模型。seven concurrency models in seven weeks" /><published>2023-08-03T00:00:00+08:00</published> <updated>2025-08-19T19:25:10+08:00</updated> <id>https://li6in9muyou.github.io/posts/concurrency-models/</id> <content src="https://li6in9muyou.github.io/posts/concurrency-models/" /> <author> <name>Li 6in9Muyou</name> </author> <category term="Reading" /> <summary> THIS IS A WORK IN PROGRESS 这本书确实没有讲到事件循环 线程和锁 使用锁元语来完成并发程序的同步和互斥需求，很容易出错，不讨论了。 函数式编程 用不可变的状态，其他的跟下面的CSP 几乎一模一样，不讨论了。 Clojure 都是语言特性，不讨论了 Actor actor 是一种由运行时维护的实体，actor 之间可以发送消息，消息是一种不可变的数据类型，被抽象为元组，消息的递送是异步的，有队列作缓存，发送消息不会阻塞，但是接收消息时如果没有消息，就会阻塞。actor 创建时，指定一个消息处理函数，如下面的cache。 跟CSP 也是很像的，靠运行时阻塞住函数执行，状态不变，但其实储存在栈帧。 def cache(pages, size) do receive do {:put, url, page} -&amp;gt; ... </summary> </entry> <entry><title>快点、再快点。the pursuit of speed</title><link href="https://li6in9muyou.github.io/posts/pursuit-of-speed/" rel="alternate" type="text/html" title="快点、再快点。the pursuit of speed" /><published>2023-07-01T00:00:00+08:00</published> <updated>2025-08-21T19:21:59+08:00</updated> <id>https://li6in9muyou.github.io/posts/pursuit-of-speed/</id> <content src="https://li6in9muyou.github.io/posts/pursuit-of-speed/" /> <author> <name>Li 6in9Muyou</name> </author> <summary> THIS IS A WORK IN PROGRESS 少做工 更优算法 利用领域知识减少做工 last N digits of fibonacci sequence is cyclic, thus one can calculate last N digits of the Xth number in the sequence with manageable time and memory mark simple inputs beforehand so that expensive checks and defensive logic can be skipped later or a faster ad-hoc algorithm can be used. see v8-json-stringify lazy loading and lazy evaluti... </summary> </entry> <entry><title>前端面试题目。crap</title><link href="https://li6in9muyou.github.io/posts/interview-questions/" rel="alternate" type="text/html" title="前端面试题目。crap" /><published>2023-07-01T00:00:00+08:00</published> <updated>2025-08-19T19:55:41+08:00</updated> <id>https://li6in9muyou.github.io/posts/interview-questions/</id> <content src="https://li6in9muyou.github.io/posts/interview-questions/" /> <author> <name>Li 6in9Muyou</name> </author> <summary> THIS IS A WORK IN PROGRESS 你说一下深拷贝和浅拷贝 深浅拷贝的概念在有运行时自动内存空间管理的编程语言中是常见的概念。 The deep copy algorithm Deep copying is naturally recursive. In lodash, the recurse entry is at a baseClone function and it supports various flavors: shallow or deep flatten inherited properties copy symbols or not At every invocation: If !isObject(value), it can be trivially cloned by returning argument ... </summary> </entry> </feed>
